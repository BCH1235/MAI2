This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.env.example
.gitignore
추가로 필요한것.txt
ai-music-backend/app-5.7.1/bin/Audiveris
ai-music-backend/app-5.7.1/bin/Audiveris.bat
ai-music-backend/app-5.7.1/lib/angus-activation-2.0.2.jar
ai-music-backend/app-5.7.1/lib/args4j-2.33.jar
ai-music-backend/app-5.7.1/lib/audiveris.jar
ai-music-backend/app-5.7.1/lib/bsaf-1.9.2.jar
ai-music-backend/app-5.7.1/lib/commons-io-2.8.0.jar
ai-music-backend/app-5.7.1/lib/commons-lang3-3.9.jar
ai-music-backend/app-5.7.1/lib/commons-logging-1.3.4.jar
ai-music-backend/app-5.7.1/lib/eventbus-1.4.jar
ai-music-backend/app-5.7.1/lib/fontbox-3.0.4.jar
ai-music-backend/app-5.7.1/lib/github-api-1.301.jar
ai-music-backend/app-5.7.1/lib/ij-1.53j.jar
ai-music-backend/app-5.7.1/lib/istack-commons-runtime-4.1.2.jar
ai-music-backend/app-5.7.1/lib/itextpdf-5.5.13.2.jar
ai-music-backend/app-5.7.1/lib/jackson-annotations-2.13.0.jar
ai-music-backend/app-5.7.1/lib/jackson-core-2.13.0.jar
ai-music-backend/app-5.7.1/lib/jackson-databind-2.13.0.jar
ai-music-backend/app-5.7.1/lib/jai-core-1.1.3.jar
ai-music-backend/app-5.7.1/lib/jai-imageio-core-1.4.0.jar
ai-music-backend/app-5.7.1/lib/jai-imageio-jpeg2000-1.4.0.jar
ai-music-backend/app-5.7.1/lib/jakarta.activation-api-2.1.3.jar
ai-music-backend/app-5.7.1/lib/jakarta.xml.bind-api-4.0.2.jar
ai-music-backend/app-5.7.1/lib/jama-1.0.3.jar
ai-music-backend/app-5.7.1/lib/javacpp-1.5.12.jar
ai-music-backend/app-5.7.1/lib/javassist-3.28.0-GA.jar
ai-music-backend/app-5.7.1/lib/javax.activation-api-1.2.0.jar
ai-music-backend/app-5.7.1/lib/jaxb-api-2.3.1.jar
ai-music-backend/app-5.7.1/lib/jaxb-core-2.3.0.1.jar
ai-music-backend/app-5.7.1/lib/jaxb-core-4.0.5.jar
ai-music-backend/app-5.7.1/lib/jaxb-impl-2.3.1.jar
ai-music-backend/app-5.7.1/lib/jaxb-runtime-4.0.5.jar
ai-music-backend/app-5.7.1/lib/jbig2-imageio-3.0.4.jar
ai-music-backend/app-5.7.1/lib/jcip-annotations-1.0.jar
ai-music-backend/app-5.7.1/lib/jfreechart-1.5.3.jar
ai-music-backend/app-5.7.1/lib/jgoodies-common-1.8.1.jar
ai-music-backend/app-5.7.1/lib/jgoodies-forms-1.9.0.jar
ai-music-backend/app-5.7.1/lib/jgoodies-looks-2.7.0.jar
ai-music-backend/app-5.7.1/lib/jgrapht-core-1.5.1.jar
ai-music-backend/app-5.7.1/lib/jheaps-0.13.jar
ai-music-backend/app-5.7.1/lib/jsr305-3.0.2.jar
ai-music-backend/app-5.7.1/lib/leptonica-1.85.0-1.5.12-windows-x86_64.jar
ai-music-backend/app-5.7.1/lib/leptonica-1.85.0-1.5.12.jar
ai-music-backend/app-5.7.1/lib/logback-classic-1.4.14.jar
ai-music-backend/app-5.7.1/lib/logback-core-1.4.14.jar
ai-music-backend/app-5.7.1/lib/org.apache.commons.io-2.4.jar
ai-music-backend/app-5.7.1/lib/pdfbox-3.0.4.jar
ai-music-backend/app-5.7.1/lib/pdfbox-io-3.0.4.jar
ai-music-backend/app-5.7.1/lib/proxymusic-4.0.3.jar
ai-music-backend/app-5.7.1/lib/reflections-0.10.2.jar
ai-music-backend/app-5.7.1/lib/slf4j-api-2.0.16.jar
ai-music-backend/app-5.7.1/lib/tesseract-5.5.1-1.5.12-windows-x86_64.jar
ai-music-backend/app-5.7.1/lib/tesseract-5.5.1-1.5.12.jar
ai-music-backend/app-5.7.1/lib/txw2-4.0.5.jar
ai-music-backend/generated_midi/00fe626c-add6-481b-b249-e266359047b3.mid
ai-music-backend/generated_midi/193064a0-1c2c-4fb6-925c-8736d38d313d.mid
ai-music-backend/generated_midi/4abb3f6b-c1d5-42b9-a488-f954c03a6d22.mid
ai-music-backend/generated_midi/4d9e9cc2-280f-4306-9d7a-08386d33240b.mid
ai-music-backend/generated_midi/54771ea9-055e-4ee5-b5a2-a27b28a9e29a.mid
ai-music-backend/generated_midi/6943ea14-61c5-420a-9d98-c6110137abe5.mid
ai-music-backend/generated_midi/696443f2-a5b2-47a1-bd16-47ad14eaa565.mid
ai-music-backend/generated_midi/6b8308be-1527-4a8b-8088-47bf5b80d43b.mid
ai-music-backend/generated_midi/6d739e76-df0b-47e0-a1a9-0831d101db77.mid
ai-music-backend/generated_midi/72bb7ca3-eff0-4d15-a616-74af6f4eaf92.mid
ai-music-backend/generated_midi/7504e681-2fb6-49f6-8447-875aa4cdd846.mid
ai-music-backend/generated_midi/7504e681-2fb6-49f6-8447-875aa4cdd846.wav
ai-music-backend/generated_midi/7f66f13b-9865-4a02-be0d-84d995775f6b.mid
ai-music-backend/generated_midi/8376aae8-ea9f-45a3-85a9-576722cf36c1.mid
ai-music-backend/generated_midi/84115a81-8316-4b0d-9599-2af287154198.mid
ai-music-backend/generated_midi/8f1784f5-0610-45ae-a459-537aadb4deab.mid
ai-music-backend/generated_midi/91dbe5ae-15d9-412d-96aa-8261ad069e02.mid
ai-music-backend/generated_midi/91dbe5ae-15d9-412d-96aa-8261ad069e02.wav
ai-music-backend/generated_midi/93a1ac25-1a71-4d3f-bb0c-7ab4cd835914.mid
ai-music-backend/generated_midi/b396da51-ce15-4f4b-8c23-41a7529d3040.mid
ai-music-backend/generated_midi/b6ae5825-9742-4db6-bae1-7e99765c2d57.mid
ai-music-backend/generated_midi/be32e1ec-6534-462d-8b32-fb687a789af0.mid
ai-music-backend/generated_midi/be32e1ec-6534-462d-8b32-fb687a789af0.wav
ai-music-backend/generated_midi/fb8eb1f2-415e-4744-a52e-a0a13cfd237a.mid
ai-music-backend/requirements.txt
ai-music-backend/server.py
ai-music-backend/temp_scores/0f23714a-e99e-426c-a52a-b8a43f6f97f7.pdf
ai-music-backend/temp_scores/2f1e0fa0-bb71-47b6-b7f6-fe2c0bfb5a65.pdf
ai-music-backend/temp_scores/373c8952-b353-4010-ac47-8049d1a7bb93.pdf
ai-music-backend/temp_scores/375127be-ff48-44f1-a8ff-317bc79021e3.pdf
ai-music-backend/temp_scores/37a9c5f0-9780-4fb2-a7d0-6d0ea0279199.pdf
ai-music-backend/temp_scores/3f7e6083-88af-4c2d-a11d-a9882da2082e.pdf
ai-music-backend/temp_scores/5a4e98fd-304a-4fec-aed2-20f2a233868a.pdf
ai-music-backend/temp_scores/6c754529-4cb7-4eef-8ec4-6ebbf02fc6bb.pdf
ai-music-backend/temp_scores/8366990d-1e37-4875-bd48-c67601412e15.pdf
ai-music-backend/temp_scores/838591e9-05a4-4555-b308-68dc929fe168.mxl
ai-music-backend/temp_scores/838591e9-05a4-4555-b308-68dc929fe168.pdf
ai-music-backend/temp_scores/8d7fc51f-f638-47c3-b6d8-985cc837227f.pdf
ai-music-backend/temp_scores/8fdb4e6b-264e-4153-9ca2-5694bf2a9250.pdf
ai-music-backend/temp_scores/a06adf5a-57ad-437d-821f-9999c064b436.pdf
ai-music-backend/temp_scores/b003e4cc-d541-40ad-a97d-04961b8d9da3.pdf
ai-music-backend/temp_scores/cca4b819-70c0-4b23-9e83-7f5638baa2b7.mxl
ai-music-backend/temp_scores/cca4b819-70c0-4b23-9e83-7f5638baa2b7.pdf
ai-music-backend/temp_scores/d05d2fed-a0e1-4aa2-9cae-114785e60add.pdf
ai-music-backend/temp_scores/daf87e00-863c-4bbb-a021-3110678e2943.mxl
ai-music-backend/temp_scores/daf87e00-863c-4bbb-a021-3110678e2943.pdf
ai-music-backend/temp_scores/db0875a6-aa17-4097-b691-d18e1ab98678.pdf
ai-music-backend/temp_scores/ebd9490f-b2ec-4002-957f-fbe36847330a.pdf
docs/firebase-integration-plan.md
images/screenshot.png
package.json
PROJECT_DOCUMENTATION.md
public/favicon.ico
public/images/genres/citypop.jpg
public/images/genres/classic.jpg
public/images/genres/edm.jpg
public/images/genres/jazz.jpg
public/images/genres/lofi.jpg
public/images/genres/README.txt
public/index.html
public/logo192.png
public/logo512.png
public/manifest.json
public/robots.txt
public/samples/505/crash.mp3
public/samples/505/hat-close.mp3
public/samples/505/hat-open.mp3
public/samples/505/kick.mp3
public/samples/505/ride.mp3
public/samples/505/snare.mp3
public/samples/505/tom-high.mp3
public/samples/505/tom-low.mp3
public/samples/505/tom-mid.mp3
README.md
src/App.css
src/App.js
src/App.test.js
src/components/beat/BeatGrid.jsx
src/components/beat/BlendPad.jsx
src/components/beat/BlendPadCanvas.jsx
src/components/beat/BlendPadGhostLayer.jsx
src/components/beat/PadToolbar.jsx
src/components/beat/PathOverlay.jsx
src/components/beat/presets.js
src/components/beat/SampleKit.js
src/components/beat/SimpleBlendPad.jsx
src/components/beat/TransportBar.jsx
src/components/common/AudioWaveform.js
src/components/common/GenreCardSelector.js
src/components/common/GenreSelector.js
src/components/common/MoodSelector.js
src/components/common/RequireAuth.jsx
src/components/layout/Navbar.js
src/context/MusicContext.js
src/hooks/useBeatMakerEngine.js
src/hooks/useCellGrid.js
src/hooks/useLerpTween.js
src/hooks/usePathMode.js
src/index.css
src/index.js
src/lib/audioUtils.js
src/lib/beatblender/cellCache.js
src/lib/beatblender/color.js
src/lib/beatblender/coords.js
src/lib/beatblender/gradients.extras.js
src/lib/beatblender/previewRender.js
src/lib/drumsVAE.js
src/lib/firebase.js
src/lib/magentaCompat.js
src/lib/toneCompat.js
src/logo.svg
src/pages/Auth.js
src/pages/Library.js
src/pages/MusicConversion.js
src/pages/MusicGeneration.js
src/pages/ResultPage.js
src/pages/ScoreToMusic.js
src/polyfills.js
src/reportWebVitals.js
src/services/libraryApi.js
src/services/libraryWriter.js
src/services/musicApi.js
src/setupTests.js
src/state/beatPadStore.js
src/styles/beatpad.css
src/utils/audioExport.js
UI_UX_DESIGN.md
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".env.example">
REACT_APP_API_BASE_URL=http://127.0.0.1:5000/api

# Firebase configuration
REACT_APP_FIREBASE_API_KEY=AIzaSyBQb-wItViVr7R0Ey89jPjBL4ihpxPXU9o
REACT_APP_FIREBASE_AUTH_DOMAIN=ai-music-lab-b0d74.firebaseapp.com
REACT_APP_FIREBASE_PROJECT_ID=ai-music-lab-b0d74
REACT_APP_FIREBASE_STORAGE_BUCKET=ai-music-lab-b0d74.firebasestorage.app
REACT_APP_FIREBASE_MESSAGING_SENDER_ID=40739414852
REACT_APP_FIREBASE_APP_ID=1:40739414852:web:21b9c1eacdff7c460e6d11
REACT_APP_FIREBASE_MEASUREMENT_ID=
</file>

<file path=".gitignore">
# See https://help.github.com/articles/ignoring-files/
# --- CRA 기본 ---
/node_modules
/.pnp
.pnp.js

# testing
/coverage

# production
/build

# misc
.DS_Store
.env.local
.env.development.local
.env.test.local
.env.production.local
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# --- 추가: 프론트엔드 ---
.env            # 루트 .env
*.env           # 혹시 다른 이름의 env 파일
*.log           # 기타 로그

# --- 추가: 백엔드(Flask) ---
ai-music-backend/.env
ai-music-backend/venv/
ai-music-backend/tmp/
ai-music-backend/static/audio/
ai-music-backend/__pycache__/
ai-music-backend/*.pyc

# --- 공통 파이썬 캐시 ---
__pycache__/
*.pyc
</file>

<file path="추가로 필요한것.txt">
FluidR3_GM 다운 -> C:\soundfonts\FluidR3_GM.sf2
fluidsynth 다운 https://github.com/FluidSynth/fluidsynth/releases/tag/v2.3.7 

시스템 변수 환경변수 추가 Path->C:\Program Files\fluidsynth\bin
</file>

<file path="ai-music-backend/app-5.7.1/bin/Audiveris">
#!/bin/sh

#
# Copyright © 2015-2021 the original authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

##############################################################################
#
#   Audiveris start up script for POSIX generated by Gradle.
#
#   Important for running:
#
#   (1) You need a POSIX-compliant shell to run this script. If your /bin/sh is
#       noncompliant, but you have some other compliant shell such as ksh or
#       bash, then to run this script, type that shell name before the whole
#       command line, like:
#
#           ksh Audiveris
#
#       Busybox and similar reduced shells will NOT work, because this script
#       requires all of these POSIX shell features:
#         * functions;
#         * expansions «$var», «${var}», «${var:-default}», «${var+SET}»,
#           «${var#prefix}», «${var%suffix}», and «$( cmd )»;
#         * compound commands having a testable exit status, especially «case»;
#         * various built-in commands including «command», «set», and «ulimit».
#
#   Important for patching:
#
#   (2) This script targets any POSIX shell, so it avoids extensions provided
#       by Bash, Ksh, etc; in particular arrays are avoided.
#
#       The "traditional" practice of packing multiple parameters into a
#       space-separated string is a well documented source of bugs and security
#       problems, so this is (mostly) avoided, by progressively accumulating
#       options in "$@", and eventually passing that to Java.
#
#       Where the inherited environment variables (DEFAULT_JVM_OPTS, JAVA_OPTS,
#       and AUDIVERIS_OPTS) rely on word-splitting, this is performed explicitly;
#       see the in-line comments for details.
#
#       There are tweaks for specific operating systems such as AIX, CygWin,
#       Darwin, MinGW, and NonStop.
#
#   (3) This script is generated from the Groovy template
#       https://github.com/gradle/gradle/blob/HEAD/subprojects/plugins/src/main/resources/org/gradle/api/internal/plugins/unixStartScript.txt
#       within the Gradle project.
#
#       You can find Gradle at https://github.com/gradle/gradle/.
#
##############################################################################

# Attempt to set APP_HOME

# Resolve links: $0 may be a link
app_path=$0

# Need this for daisy-chained symlinks.
while
    APP_HOME=${app_path%"${app_path##*/}"}  # leaves a trailing /; empty if no leading path
    [ -h "$app_path" ]
do
    ls=$( ls -ld "$app_path" )
    link=${ls#*' -> '}
    case $link in             #(
      /*)   app_path=$link ;; #(
      *)    app_path=$APP_HOME$link ;;
    esac
done

# This is normally unused
# shellcheck disable=SC2034
APP_BASE_NAME=${0##*/}
# Discard cd standard output in case $CDPATH is set (https://github.com/gradle/gradle/issues/25036)
APP_HOME=$( cd "${APP_HOME:-./}.." > /dev/null && pwd -P ) || exit

# Use the maximum available, or set MAX_FD != -1 to use that value.
MAX_FD=maximum

warn () {
    echo "$*"
} >&2

die () {
    echo
    echo "$*"
    echo
    exit 1
} >&2

# OS specific support (must be 'true' or 'false').
cygwin=false
msys=false
darwin=false
nonstop=false
case "$( uname )" in                #(
  CYGWIN* )         cygwin=true  ;; #(
  Darwin* )         darwin=true  ;; #(
  MSYS* | MINGW* )  msys=true    ;; #(
  NONSTOP* )        nonstop=true ;;
esac

CLASSPATH=$APP_HOME/lib/audiveris.jar:$APP_HOME/lib/args4j-2.33.jar:$APP_HOME/lib/logback-classic-1.4.14.jar:$APP_HOME/lib/jai-imageio-jpeg2000-1.4.0.jar:$APP_HOME/lib/jai-imageio-core-1.4.0.jar:$APP_HOME/lib/itextpdf-5.5.13.2.jar:$APP_HOME/lib/jgoodies-forms-1.9.0.jar:$APP_HOME/lib/jgoodies-looks-2.7.0.jar:$APP_HOME/lib/jaxb-core-2.3.0.1.jar:$APP_HOME/lib/jaxb-impl-2.3.1.jar:$APP_HOME/lib/jama-1.0.3.jar:$APP_HOME/lib/jai-core-1.1.3.jar:$APP_HOME/lib/jaxb-api-2.3.1.jar:$APP_HOME/lib/ij-1.53j.jar:$APP_HOME/lib/jcip-annotations-1.0.jar:$APP_HOME/lib/org.apache.commons.io-2.4.jar:$APP_HOME/lib/jbig2-imageio-3.0.4.jar:$APP_HOME/lib/pdfbox-3.0.4.jar:$APP_HOME/lib/fontbox-3.0.4.jar:$APP_HOME/lib/pdfbox-io-3.0.4.jar:$APP_HOME/lib/proxymusic-4.0.3.jar:$APP_HOME/lib/eventbus-1.4.jar:$APP_HOME/lib/tesseract-5.5.1-1.5.12.jar:$APP_HOME/lib/tesseract-5.5.1-1.5.12-windows-x86_64.jar:$APP_HOME/lib/leptonica-1.85.0-1.5.12.jar:$APP_HOME/lib/leptonica-1.85.0-1.5.12-windows-x86_64.jar:$APP_HOME/lib/javacpp-1.5.12.jar:$APP_HOME/lib/bsaf-1.9.2.jar:$APP_HOME/lib/jfreechart-1.5.3.jar:$APP_HOME/lib/jgrapht-core-1.5.1.jar:$APP_HOME/lib/github-api-1.301.jar:$APP_HOME/lib/reflections-0.10.2.jar:$APP_HOME/lib/slf4j-api-2.0.16.jar:$APP_HOME/lib/logback-core-1.4.14.jar:$APP_HOME/lib/jgoodies-common-1.8.1.jar:$APP_HOME/lib/javax.activation-api-1.2.0.jar:$APP_HOME/lib/commons-io-2.8.0.jar:$APP_HOME/lib/commons-logging-1.3.4.jar:$APP_HOME/lib/jaxb-runtime-4.0.5.jar:$APP_HOME/lib/jaxb-core-4.0.5.jar:$APP_HOME/lib/jakarta.xml.bind-api-4.0.2.jar:$APP_HOME/lib/jheaps-0.13.jar:$APP_HOME/lib/commons-lang3-3.9.jar:$APP_HOME/lib/jackson-annotations-2.13.0.jar:$APP_HOME/lib/jackson-core-2.13.0.jar:$APP_HOME/lib/jackson-databind-2.13.0.jar:$APP_HOME/lib/javassist-3.28.0-GA.jar:$APP_HOME/lib/jsr305-3.0.2.jar:$APP_HOME/lib/angus-activation-2.0.2.jar:$APP_HOME/lib/jakarta.activation-api-2.1.3.jar:$APP_HOME/lib/txw2-4.0.5.jar:$APP_HOME/lib/istack-commons-runtime-4.1.2.jar


# Determine the Java command to use to start the JVM.
if [ -n "$JAVA_HOME" ] ; then
    if [ -x "$JAVA_HOME/jre/sh/java" ] ; then
        # IBM's JDK on AIX uses strange locations for the executables
        JAVACMD=$JAVA_HOME/jre/sh/java
    else
        JAVACMD=$JAVA_HOME/bin/java
    fi
    if [ ! -x "$JAVACMD" ] ; then
        die "ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME

Please set the JAVA_HOME variable in your environment to match the
location of your Java installation."
    fi
else
    JAVACMD=java
    if ! command -v java >/dev/null 2>&1
    then
        die "ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.

Please set the JAVA_HOME variable in your environment to match the
location of your Java installation."
    fi
fi

# Increase the maximum file descriptors if we can.
if ! "$cygwin" && ! "$darwin" && ! "$nonstop" ; then
    case $MAX_FD in #(
      max*)
        # In POSIX sh, ulimit -H is undefined. That's why the result is checked to see if it worked.
        # shellcheck disable=SC2039,SC3045
        MAX_FD=$( ulimit -H -n ) ||
            warn "Could not query maximum file descriptor limit"
    esac
    case $MAX_FD in  #(
      '' | soft) :;; #(
      *)
        # In POSIX sh, ulimit -n is undefined. That's why the result is checked to see if it worked.
        # shellcheck disable=SC2039,SC3045
        ulimit -n "$MAX_FD" ||
            warn "Could not set maximum file descriptor limit to $MAX_FD"
    esac
fi

# Collect all arguments for the java command, stacking in reverse order:
#   * args from the command line
#   * the main class name
#   * -classpath
#   * -D...appname settings
#   * --module-path (only if needed)
#   * DEFAULT_JVM_OPTS, JAVA_OPTS, and AUDIVERIS_OPTS environment variables.

# For Cygwin or MSYS, switch paths to Windows format before running java
if "$cygwin" || "$msys" ; then
    APP_HOME=$( cygpath --path --mixed "$APP_HOME" )
    CLASSPATH=$( cygpath --path --mixed "$CLASSPATH" )

    JAVACMD=$( cygpath --unix "$JAVACMD" )

    # Now convert the arguments - kludge to limit ourselves to /bin/sh
    for arg do
        if
            case $arg in                                #(
              -*)   false ;;                            # don't mess with options #(
              /?*)  t=${arg#/} t=/${t%%/*}              # looks like a POSIX filepath
                    [ -e "$t" ] ;;                      #(
              *)    false ;;
            esac
        then
            arg=$( cygpath --path --ignore --mixed "$arg" )
        fi
        # Roll the args list around exactly as many times as the number of
        # args, so each arg winds up back in the position where it started, but
        # possibly modified.
        #
        # NB: a `for` loop captures its iteration list before it begins, so
        # changing the positional parameters here affects neither the number of
        # iterations, nor the values presented in `arg`.
        shift                   # remove old arg
        set -- "$@" "$arg"      # push replacement arg
    done
fi

# Start script customization ---

# Actual value for min_java_version is to be provided by script post-processing
min_java_version="24" 
java_version=$("$JAVACMD" -version 2>&1 | head -1 | cut -d'"' -f2 | sed 's/^1\.//' | cut -d'.' -f1)

if [ $java_version -lt $min_java_version ]
then
  die "Java $min_java_version or higher is required. You have version $java_version"
fi

# Stop script customization ---


# Add default JVM options here. You can also use JAVA_OPTS and AUDIVERIS_OPTS to pass JVM options to this script.
DEFAULT_JVM_OPTS='"--add-exports=java.desktop/sun.awt.image=ALL-UNNAMED" "--enable-native-access=ALL-UNNAMED"'

# Collect all arguments for the java command:
#   * DEFAULT_JVM_OPTS, JAVA_OPTS, JAVA_OPTS, and optsEnvironmentVar are not allowed to contain shell fragments,
#     and any embedded shellness will be escaped.
#   * For example: A user cannot expect ${Hostname} to be expanded, as it is an environment variable and will be
#     treated as '${Hostname}' itself on the command line.

set -- \
        -classpath "$CLASSPATH" \
        Audiveris \
        "$@"

# Stop when "xargs" is not available.
if ! command -v xargs >/dev/null 2>&1
then
    die "xargs is not available"
fi

# Use "xargs" to parse quoted args.
#
# With -n1 it outputs one arg per line, with the quotes and backslashes removed.
#
# In Bash we could simply go:
#
#   readarray ARGS < <( xargs -n1 <<<"$var" ) &&
#   set -- "${ARGS[@]}" "$@"
#
# but POSIX shell has neither arrays nor command substitution, so instead we
# post-process each arg (as a line of input to sed) to backslash-escape any
# character that might be a shell metacharacter, then use eval to reverse
# that process (while maintaining the separation between arguments), and wrap
# the whole thing up as a single "set" statement.
#
# This will of course break if any of these variables contains a newline or
# an unmatched quote.
#

eval "set -- $(
        printf '%s\n' "$DEFAULT_JVM_OPTS $JAVA_OPTS $AUDIVERIS_OPTS" |
        xargs -n1 |
        sed ' s~[^-[:alnum:]+,./:=@_]~\\&~g; ' |
        tr '\n' ' '
    )" '"$@"'

exec "$JAVACMD" "$@"
</file>

<file path="ai-music-backend/app-5.7.1/bin/Audiveris.bat">
@rem
@rem Copyright 2015 the original author or authors.
@rem
@rem Licensed under the Apache License, Version 2.0 (the "License");
@rem you may not use this file except in compliance with the License.
@rem You may obtain a copy of the License at
@rem
@rem      https://www.apache.org/licenses/LICENSE-2.0
@rem
@rem Unless required by applicable law or agreed to in writing, software
@rem distributed under the License is distributed on an "AS IS" BASIS,
@rem WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@rem See the License for the specific language governing permissions and
@rem limitations under the License.
@rem

@if "%DEBUG%"=="" @echo off
@rem ##########################################################################
@rem
@rem  Audiveris startup script for Windows
@rem
@rem ##########################################################################

@rem Set local scope for the variables with windows NT shell
if "%OS%"=="Windows_NT" setlocal

set DIRNAME=%~dp0
if "%DIRNAME%"=="" set DIRNAME=.
@rem This is normally unused
set APP_BASE_NAME=%~n0
set APP_HOME=%DIRNAME%..

@rem Resolve any "." and ".." in APP_HOME to make it shorter.
for %%i in ("%APP_HOME%") do set APP_HOME=%%~fi

@rem Add default JVM options here. You can also use JAVA_OPTS and AUDIVERIS_OPTS to pass JVM options to this script.
set DEFAULT_JVM_OPTS="--add-exports=java.desktop/sun.awt.image=ALL-UNNAMED" "--enable-native-access=ALL-UNNAMED"

@rem Find java.exe
if defined JAVA_HOME goto findJavaFromJavaHome

set JAVA_EXE=java.exe
%JAVA_EXE% -version >NUL 2>&1
if %ERRORLEVEL% equ 0 goto execute

echo.
echo ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
echo.
echo Please set the JAVA_HOME variable in your environment to match the
echo location of your Java installation.

goto fail

:findJavaFromJavaHome
set JAVA_HOME=%JAVA_HOME:"=%
set JAVA_EXE=%JAVA_HOME%/bin/java.exe

if exist "%JAVA_EXE%" goto execute

echo.
echo ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME%
echo.
echo Please set the JAVA_HOME variable in your environment to match the
echo location of your Java installation.

goto fail

:execute

@rem Start script customization ---

@rem Actual value for min_java_version is to be provided by script post-processing
set /a min_java_version=24

for /f tokens^=2-5^ delims^=.-_^" %%j in ('"%JAVA_EXE%" -fullversion 2^>^&1') do (
    set "full_version=%%j.%%k.%%l-%%m"
    set "version=%%j"
)

if %version% LSS %min_java_version% (
    echo WARNING:
    echo WARNING: Current Java version %version% is lower than required %min_java_version%
    echo WARNING: Please install Java version %min_java_version% or higher
    echo WARNING:
@rem    start cmd /c "@echo off & mode con cols=50 lines=10 & echo // & echo // Audiveris WARNING: & echo // & echo // Your Java version is %version% (%full_version%) & echo // Please, install Java %min_java_version% or above. & echo // & pause"
    pause
    goto fail
)

@rem Stop script customization ---

@rem Setup the command line

set CLASSPATH=%APP_HOME%\lib\audiveris.jar;%APP_HOME%\lib\args4j-2.33.jar;%APP_HOME%\lib\logback-classic-1.4.14.jar;%APP_HOME%\lib\jai-imageio-jpeg2000-1.4.0.jar;%APP_HOME%\lib\jai-imageio-core-1.4.0.jar;%APP_HOME%\lib\itextpdf-5.5.13.2.jar;%APP_HOME%\lib\jgoodies-forms-1.9.0.jar;%APP_HOME%\lib\jgoodies-looks-2.7.0.jar;%APP_HOME%\lib\jaxb-core-2.3.0.1.jar;%APP_HOME%\lib\jaxb-impl-2.3.1.jar;%APP_HOME%\lib\jama-1.0.3.jar;%APP_HOME%\lib\jai-core-1.1.3.jar;%APP_HOME%\lib\jaxb-api-2.3.1.jar;%APP_HOME%\lib\ij-1.53j.jar;%APP_HOME%\lib\jcip-annotations-1.0.jar;%APP_HOME%\lib\org.apache.commons.io-2.4.jar;%APP_HOME%\lib\jbig2-imageio-3.0.4.jar;%APP_HOME%\lib\pdfbox-3.0.4.jar;%APP_HOME%\lib\fontbox-3.0.4.jar;%APP_HOME%\lib\pdfbox-io-3.0.4.jar;%APP_HOME%\lib\proxymusic-4.0.3.jar;%APP_HOME%\lib\eventbus-1.4.jar;%APP_HOME%\lib\tesseract-5.5.1-1.5.12.jar;%APP_HOME%\lib\tesseract-5.5.1-1.5.12-windows-x86_64.jar;%APP_HOME%\lib\leptonica-1.85.0-1.5.12.jar;%APP_HOME%\lib\leptonica-1.85.0-1.5.12-windows-x86_64.jar;%APP_HOME%\lib\javacpp-1.5.12.jar;%APP_HOME%\lib\bsaf-1.9.2.jar;%APP_HOME%\lib\jfreechart-1.5.3.jar;%APP_HOME%\lib\jgrapht-core-1.5.1.jar;%APP_HOME%\lib\github-api-1.301.jar;%APP_HOME%\lib\reflections-0.10.2.jar;%APP_HOME%\lib\slf4j-api-2.0.16.jar;%APP_HOME%\lib\logback-core-1.4.14.jar;%APP_HOME%\lib\jgoodies-common-1.8.1.jar;%APP_HOME%\lib\javax.activation-api-1.2.0.jar;%APP_HOME%\lib\commons-io-2.8.0.jar;%APP_HOME%\lib\commons-logging-1.3.4.jar;%APP_HOME%\lib\jaxb-runtime-4.0.5.jar;%APP_HOME%\lib\jaxb-core-4.0.5.jar;%APP_HOME%\lib\jakarta.xml.bind-api-4.0.2.jar;%APP_HOME%\lib\jheaps-0.13.jar;%APP_HOME%\lib\commons-lang3-3.9.jar;%APP_HOME%\lib\jackson-annotations-2.13.0.jar;%APP_HOME%\lib\jackson-core-2.13.0.jar;%APP_HOME%\lib\jackson-databind-2.13.0.jar;%APP_HOME%\lib\javassist-3.28.0-GA.jar;%APP_HOME%\lib\jsr305-3.0.2.jar;%APP_HOME%\lib\angus-activation-2.0.2.jar;%APP_HOME%\lib\jakarta.activation-api-2.1.3.jar;%APP_HOME%\lib\txw2-4.0.5.jar;%APP_HOME%\lib\istack-commons-runtime-4.1.2.jar


@rem Execute Audiveris
"%JAVA_EXE%" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %AUDIVERIS_OPTS%  -classpath "%CLASSPATH%" Audiveris %*

:end
@rem End local scope for the variables with windows NT shell
if %ERRORLEVEL% equ 0 goto mainEnd

:fail
rem Set variable AUDIVERIS_EXIT_CONSOLE if you need the _script_ return code instead of
rem the _cmd.exe /c_ return code!
set EXIT_CODE=%ERRORLEVEL%
if %EXIT_CODE% equ 0 set EXIT_CODE=1
if not ""=="%AUDIVERIS_EXIT_CONSOLE%" exit %EXIT_CODE%
exit /b %EXIT_CODE%

:mainEnd
if "%OS%"=="Windows_NT" endlocal

:omega
</file>

<file path="ai-music-backend/requirements.txt">
flask
flask-cors
python-dotenv
requests
huggingface_hub
replicate
</file>

<file path="ai-music-backend/server.py">
import os
import uuid
import time
import threading
import subprocess
from io import BytesIO
from pathlib import Path
from typing import Any, Dict, Optional, List

from flask import Flask, request, jsonify, send_file
from flask_cors import CORS
from dotenv import load_dotenv
from werkzeug.utils import secure_filename
import replicate
from music21 import converter
from midi2audio import FluidSynth

# ───── env ──────────────────────────────────────────────────────────
load_dotenv(dotenv_path=Path(__file__).parent / ".env", override=True)

REPLICATE_TOKEN = os.getenv("REPLICATE_API_TOKEN")
MODEL_SLUG = os.getenv("REPLICATE_MODEL", "meta/musicgen")
client = replicate.Client(api_token=REPLICATE_TOKEN) if REPLICATE_TOKEN else None

PAPAGO_CLIENT_ID = os.getenv("PAPAGO_CLIENT_ID")
PAPAGO_CLIENT_SECRET = os.getenv("PAPAGO_CLIENT_SECRET")

# ───── Flask app ────────────────────────────────────────────────────
app = Flask(__name__)
CORS(app)

UPLOAD_FOLDER = os.path.join(os.path.dirname(os.path.abspath(__file__)), "uploads")
OUTPUT_FOLDER = os.path.join(os.path.dirname(os.path.abspath(__file__)), "outputs")
os.makedirs(UPLOAD_FOLDER, exist_ok=True)
os.makedirs(OUTPUT_FOLDER, exist_ok=True)

STATIC_FOLDER = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'static')
os.makedirs(STATIC_FOLDER, exist_ok=True)

fluidsynth_executable_path = r'C:\Program Files\FluidSynth\bin'
if fluidsynth_executable_path not in os.environ['PATH']:
    os.environ['PATH'] += os.pathsep + fluidsynth_executable_path

# ───── in-memory task 관리 ───────────────────────────────────────────
TASKS: Dict[str, Dict[str, Any]] = {}

def _set_task_status(task_id: str, status: str, **kwargs):
    TASKS[task_id] = {"status": status, **kwargs}

# ───── Papago 번역 API ───────────────────────────────────────────
def translate_to_english(text: str) -> str:
    """Papago API를 사용하여 한국어 텍스트를 영어로 번역하는 함수"""
    # --- [디버깅 로그] ---
    print("\n--- Papago 번역 시작 ---")
    print(f"[Papago] 원본 텍스트: '{text}'")
    
    if not all([PAPAGO_CLIENT_ID, PAPAGO_CLIENT_SECRET]):
        print("[Papago] Papago API 키가 설정되지 않아 번역을 건너뜁니다.")
        print("--- Papago 번역 종료 ---\n")
        return text
    if not text or not text.strip():
        print("[Papago] 입력 텍스트가 비어있어 번역을 건너뜁니다.")
        print("--- Papago 번역 종료 ---\n")
        return text

    try:
        url = "https://papago.apigw.ntruss.com/nmt/v1/translation"
        headers = {
            "X-NCP-APIGW-API-KEY-ID": PAPAGO_CLIENT_ID,
            "X-NCP-APIGW-API-KEY": PAPAGO_CLIENT_SECRET,
        }
        data = {"source": "ko", "target": "en", "text": text}
        
        # --- [디버깅 로그] ---
        print("[Papago] API 서버로 번역을 요청합니다...")
        response = requests.post(url, headers=headers, data=data, timeout=5)
        
        if response.status_code != 200:
            # --- [디버깅 로그] ---
            print(f"[Papago Error] API가 오류를 반환했습니다. 상태 코드: {response.status_code}")
            print(f"[Papago Error] 응답 내용: {response.text}")
            print("--- Papago 번역 종료 ---\n")
            return text # 오류 시 원본 텍스트 반환

        result = response.json()
        translated_text = result.get("message", {}).get("result", {}).get("translatedText")
        
        if translated_text:
            # --- [디버깅 로그] ---
            print(f"[Papago] ✨ 번역 성공! ✨ -> '{translated_text}'")
            print("--- Papago 번역 종료 ---\n")
            return translated_text
        
        # --- [디버깅 로그] ---
        print("[Papago] 번역된 텍스트를 찾을 수 없어 원본을 반환합니다.")
        print("--- Papago 번역 종료 ---\n")
        return text

    except requests.exceptions.RequestException as e:
        print(f"[Papago Error] API 요청 실패: {e}")
        print("--- Papago 번역 종료 ---\n")
        return text
    except Exception as e:
        print(f"[Papago Error] 알 수 없는 오류: {e}")
        print("--- Papago 번역 종료 ---\n")
        return text

# ───── Replicate AI 음악 생성 ───────────────────────────────────────
def mk_result(audio_url: str, title="AI_Track",
              genres: Optional[List[str]] = None,
              moods: Optional[List[str]] = None,
              duration: int = 10, kind: str = "generated"):
    return {
        "id": str(uuid.uuid4()),
        "title": title,
        "genres": genres or [],
        "moods": moods or [],
        "duration": duration,
        "audioUrl": audio_url,
        "createdAt": time.strftime("%Y-%m-%dT%H:%M:%SZ"),
        "type": kind,
    }

def _extract_audio_url(output: Any) -> Optional[str]:
    def as_url(v: Any) -> Optional[str]:
        if isinstance(v, str) and v.startswith("http"): return v
        try:
            u = getattr(v, "url", None)
            if isinstance(u, str) and u.startswith("http"): return u
        except Exception:
            pass
        return None

    u = as_url(output)
    if u: return u
    if isinstance(output, (list, tuple)):
        for item in output:
            u = as_url(item)
            if u: return u
    if isinstance(output, dict):
        for key in ("audioUrl", "audio_url", "url", "audio", "output"):
            if key in output:
                u = as_url(output[key])
                if u: return u
        files = output.get("files")
        if isinstance(files, list):
            for f in files:
                if isinstance(f, dict):
                    u = as_url(f.get("url"))
                    if u: return u
                else:
                    u = as_url(f)
                    if u: return u
        for parent in ("result", "data", "prediction"):
            if parent in output:
                u = _extract_audio_url(output[parent])
                if u: return u
    return None

def _run_replicate(input_dict: Dict[str, Any]) -> str:
    if not client:
        raise RuntimeError("No Replicate token loaded from .env")
    out = client.run(MODEL_SLUG, input=input_dict)
    url = _extract_audio_url(out)
    if not url:
        raise RuntimeError(f"Replicate returned no audio URL. raw={out}")
    return url

def worker_generate(task_id: str, prompt: str, genres, moods, duration: int,
                    tmp_path: Optional[str]):
    try:
        _set_task_status(task_id, "running")
        inputs: Dict[str, Any] = {
            "prompt": prompt or "instrumental background music",
            "duration": duration,
            "output_format": "mp3",
            "normalization_strategy": "peak",
        }
        if tmp_path:
            with open(tmp_path, "rb") as f:
                data = f.read()
            bio = BytesIO(data)
            setattr(bio, "name", os.path.basename(tmp_path))
            bio.seek(0)
            inputs["input_audio"] = bio
            inputs["continuation"] = False

        audio_url = _run_replicate(inputs)
        res = mk_result(audio_url, "AI_Generated_Track", genres, moods, duration, "generated")
        _set_task_status(task_id, "succeeded", result=res, audioUrl=res["audioUrl"])
    except Exception as e:
        print("[worker_generate] ERROR:", repr(e))
        _set_task_status(task_id, "failed", error=str(e))
    finally:
        if tmp_path:
            try: os.remove(tmp_path)
            except: pass

# ───── PDF → MusicXML → MIDI/WAV/MP3 변환 ─────────────────────────
@app.route('/api/process-score', methods=['POST'])
def process_score():
    if 'score' not in request.files:
        return jsonify({'message': '악보 파일이 없습니다.'}), 400
    
    uploaded_file = request.files['score']

    if uploaded_file.filename == '':
        return jsonify({'message': '파일이 선택되지 않았습니다.'}), 400

    if uploaded_file and uploaded_file.filename.endswith('.pdf'):
        # --- 1. 경로 설정 ---
        backend_dir = os.path.dirname(os.path.abspath(__file__))
        upload_folder = os.path.join(backend_dir, 'temp_scores')
        midi_folder = os.path.join(backend_dir, 'generated_midi')
        os.makedirs(upload_folder, exist_ok=True)
        os.makedirs(midi_folder, exist_ok=True)
        
        unique_filename = str(uuid.uuid4())
        pdf_path = os.path.join(upload_folder, f"{unique_filename}.pdf")
        uploaded_file.save(pdf_path)

        # --- 2. Audiveris 실행 경로 설정 ---
        audiveris_jar_path = r"C:\Program Files\Audiveris\app"
        java_executable = r"C:\Program Files\Audiveris\runtime\bin\java"

        try:
            # --- 3. Audiveris 실행 (PDF -> MusicXML) ---
            print(f"Audiveris 실행 시작: {pdf_path}")
            print(f"Audiveris jar 경로: {audiveris_jar_path}")
            
            jar_files = []
            for file_name in os.listdir(audiveris_jar_path):
                if file_name.endswith('.jar'):
                    jar_files.append(os.path.join(audiveris_jar_path, file_name))
            
            classpath = ';'.join(jar_files)
            print(f"클래스패스에 {len(jar_files)}개 JAR 파일 추가")
            
            result = subprocess.run(
                [
                    java_executable,
                    '-cp', classpath,
                    '-Djava.awt.headless=true',
                    '-Xmx2g',
                    '-Duser.language=en',
                    '-Duser.country=US',
                    'org.audiveris.omr.Main',
                    '-batch',
                    '-export',
                    '-output', upload_folder,
                    pdf_path
                ],
                capture_output=True,
                text=True,
                encoding='utf-8',
                timeout=1800
            )

            print("Audiveris 실행 완료")

            if result.returncode != 0:
                print("----- Audiveris Stderr -----")
                print(result.stderr)
                print("----- Audiveris Stdout -----")
                print(result.stdout)
                
                if "UnsupportedClassVersionError" in result.stderr or "Preview features" in result.stderr:
                    raise subprocess.CalledProcessError(result.returncode, result.args, result.stdout, result.stderr)
                elif "No installed OCR languages" in result.stdout:
                    print("OCR 언어 패키지가 없지만 악보 인식은 계속 진행합니다.")
                else:
                    raise subprocess.CalledProcessError(result.returncode, result.args, result.stdout, result.stderr)

            # --- 4. 변환된 MusicXML 파일 찾기 ---
            print(f"출력 폴더 내용 확인: {os.listdir(upload_folder)}")
            
            base_pdf_name = os.path.splitext(os.path.basename(pdf_path))[0]
            possible_extensions = ['.mxl', '.xml', '.musicxml']
            music_file_path = None
            
            for ext in possible_extensions:
                potential_path = os.path.join(upload_folder, f"{base_pdf_name}{ext}")
                if os.path.exists(potential_path):
                    music_file_path = potential_path
                    print(f"변환된 파일 발견: {music_file_path}")
                    break
            
            if not music_file_path:
                for file_item in os.listdir(upload_folder):
                    if any(file_item.endswith(ext) for ext in possible_extensions):
                        music_file_path = os.path.join(upload_folder, file_item)
                        print(f"폴더 검색으로 발견된 파일: {music_file_path}")
                        break
            
            if not music_file_path or not os.path.exists(music_file_path):
                raise FileNotFoundError("MusicXML 파일이 변환 후 생성되지 않았습니다.")

        except subprocess.TimeoutExpired:
            print("!!! Audiveris 실행 시간 초과 !!!")
            return jsonify({'message': '악보 변환 작업이 너무 오래 걸려 중단되었습니다.'}), 500
        except subprocess.CalledProcessError as e:
            return jsonify({'message': 'PDF를 MusicXML로 변환하는데 실패했습니다.'}), 500
        except FileNotFoundError as e:
            print(f"파일을 찾을 수 없습니다: {e}")
            return jsonify({'message': '변환된 MusicXML 파일을 찾을 수 없습니다.'}), 500

        # --- 5. MusicXML -> WAV 변환 (반복 기호 오류 처리) ---
        try:
            print(f"Music21로 파일 파싱 시작: {music_file_path}")
            score = converter.parse(music_file_path)
            
            # MIDI 파일 생성
            midi_filename = f"{unique_filename}.mid"
            midi_path = os.path.join(midi_folder, midi_filename)
            
            print(f"MIDI 파일 생성 중: {midi_path}")
            
            # 반복 기호 처리 시도
            try:
                # 1차 시도: 반복 기호 확장
                expanded_score = score.expandRepeats()
                expanded_score.write('midi', fp=midi_path)
                print(f"MIDI 파일 생성 완료 (반복 확장): {midi_path}")
            except Exception as repeat_error:
                print(f"반복 확장 실패: {repeat_error}")
                try:
                    # 2차 시도: 반복 기호 무시하고 생성
                    print("반복 기호를 제거하고 다시 시도합니다...")
                    
                    # 모든 반복 기호 제거
                    for part in score.parts:
                        for measure in part.getElementsByClass('Measure'):
                            # 반복 기호 제거
                            for repeat in measure.getElementsByClass('Repeat'):
                                measure.remove(repeat)
                            for barline in measure.getElementsByClass('Barline'):
                                if barline.type in ['regular', 'final']:
                                    continue
                                measure.remove(barline)
                    
                    score.write('midi', fp=midi_path)
                    print(f"MIDI 파일 생성 완료 (반복 제거): {midi_path}")
                except Exception as fallback_error:
                    print(f"반복 제거 후에도 실패: {fallback_error}")
                    # 3차 시도: flatten으로 단순화
                    try:
                        print("악보를 단순화하여 다시 시도합니다...")
                        flat_score = score.flatten()
                        flat_score.write('midi', fp=midi_path)
                        print(f"MIDI 파일 생성 완료 (단순화): {midi_path}")
                    except Exception as final_error:
                        print(f"모든 변환 시도 실패: {final_error}")
                        raise Exception(f"MIDI 변환 실패: {final_error}")
            
            # WAV 파일로 변환
            wav_filename = f"{unique_filename}.wav"
            wav_path = os.path.join(midi_folder, wav_filename)
            
            try:
                print(f"WAV 파일 변환 중: {wav_path}")
                fs = FluidSynth(sound_font=r'C:\soundfonts\FluidR3_GM.sf2')
                fs.midi_to_audio(midi_path, wav_path)
                print(f"WAV 파일 생성 완료: {wav_path}")
                
                audio_url = f"http://127.0.0.1:5000/api/audio/{wav_filename}"
                audio_path = wav_path
            except Exception as e:
                print(f"FluidSynth 변환 실패: {e}")
                import traceback
                traceback.print_exc()
                print("MIDI 파일을 그대로 사용합니다")
                audio_url = f"http://127.0.0.1:5000/api/audio/{midi_filename}"
                audio_path = midi_path
            
            # 곡 길이 계산
            try:
                if score.metronomeMarkBoundaries():
                    tempo = score.metronomeMarkBoundaries()[0][-1].number
                    duration = int(score.duration.quarterLength / tempo * 60)
                else:
                    duration = 180
            except:
                duration = 180

            # 결과 데이터 생성
            result_data = {
                "id": unique_filename,
                "title": f"악보 연주 - {uploaded_file.filename}",
                "audioUrl": audio_url,
                "audioPath": audio_path,
                "genres": ["Classical"],
                "moods": [],
                "duration": duration,
                "createdAt": time.strftime("%Y-%m-%dT%H:%M:%SZ"),
                "type": "score-audio"
            }

            print(f"오디오 파일 준비 완료: {result_data}")
            
            # Task ID 생성 및 저장
            task_id = uuid.uuid4().hex
            _set_task_status(task_id, "succeeded", result=result_data, audioUrl=audio_url)
            print(f"Task ID 생성: {task_id}")

        except Exception as e:
            print(f"오디오 변환 오류: {e}")
            import traceback
            traceback.print_exc()
            return jsonify({'message': f'오디오 변환 중 오류가 발생했습니다: {str(e)}'}), 500

        finally:
            # 임시 파일 정리
            try:
                os.remove(pdf_path)
                if music_file_path and os.path.exists(music_file_path):
                    os.remove(music_file_path)
                for file_item in os.listdir(upload_folder):
                    if file_item.endswith(('.log', '.omr')):
                        try:
                            os.remove(os.path.join(upload_folder, file_item))
                        except:
                            pass
            except Exception as cleanup_error:
                print(f"파일 정리 중 오류: {cleanup_error}")
        
        # taskId 반환 (다른 API와 동일한 형식)
        return jsonify({
            'taskId': task_id
        })

    return jsonify({'message': '잘못된 파일 형식입니다.'}), 400

# ───── 오디오 서빙 ────────────────────────────────────────────────
@app.route('/api/audio/<filename>', methods=['GET'])
def serve_audio(filename):
    # 여러 폴더에서 파일 찾기
    backend_dir = os.path.dirname(os.path.abspath(__file__))
    
    possible_paths = [
        os.path.join(backend_dir, 'generated_midi', filename),  # 악보 변환 파일
        os.path.join(OUTPUT_FOLDER, filename),                   # AI 생성 파일
        os.path.join(STATIC_FOLDER, filename)                    # 기타 파일
    ]
    
    for audio_path in possible_paths:
        if os.path.exists(audio_path):
            print(f"파일 제공: {audio_path}")
            return send_file(audio_path)
    
    print(f"파일을 찾을 수 없음: {filename}")
    print(f"검색한 경로들:")
    for path in possible_paths:
        print(f"  - {path} (존재: {os.path.exists(path)})")
    
    return jsonify({'error': '파일이 존재하지 않습니다.'}), 404

# ───── AI 음악 생성 엔드포인트 ─────────────────────────────────────
@app.route("/api/music/generate", methods=["POST"])
def generate_music():
    ct = (request.content_type or "")
    is_multipart = ct.startswith("multipart/form-data")

    if is_multipart:
        data = request.form
        up = request.files.get("file")
    else:   
        data = request.get_json(force=True, silent=True) or {}
        up = None

    import json
    def as_list(v):
        if v is None: return []
        if isinstance(v, list): return v
        if isinstance(v, str):
            try: return json.loads(v)
            except: return [v] if v else []
        return []

    prompt = data.get("description") or "instrumental background music"
    genres = as_list(data.get("genres"))
    moods = as_list(data.get("moods"))
    try: duration = int(data.get("duration") or 10)
    except: duration = 10

    tmp_path = None
    if up:
        os.makedirs("tmp", exist_ok=True)
        safe = secure_filename(up.filename or f"audio_{uuid.uuid4().hex}.wav")
        tmp_path = os.path.join("tmp", f"{uuid.uuid4().hex}_{safe}")
        up.save(tmp_path)

    task_id = uuid.uuid4().hex
    _set_task_status(task_id, "queued")
    threading.Thread(target=worker_generate,
                     args=(task_id, prompt, genres, moods, duration, tmp_path),
                     daemon=True).start()
    return jsonify({"taskId": task_id})

@app.route("/api/music/task/status", methods=["GET"])
def task_status():
    task_id = request.args.get("task_id") or request.args.get("taskId")
    task = TASKS.get(task_id)
    if not task:
        return jsonify({"status": "failed", "error": "Unknown task"}), 404
    return jsonify({
        "taskId": task_id,
        "status": task.get("status"),
        "audioUrl": task.get("audioUrl"),
        "result": task.get("result"),
        "error": task.get("error"),
    })

# ───── 서버 실행 ─────────────────────────────────────────────────
if __name__ == "__main__":
    app.run(host="127.0.0.1", port=5000, debug=True)
</file>

<file path="docs/firebase-integration-plan.md">
# Firebase Integration & Auth Plan

## 1. 목표와 범위
- 라이브러리 페이지에 사용자별 음악/비트 데이터를 Firestore에서 읽어와 표시한다.
- 음악 생성/비트 생성 워크플로가 완료될 때 결과 메타데이터와 오디오 파일을 Firebase에 저장한다.
- Firebase Authentication을 이용해 이메일/비밀번호 기반 회원가입과 로그인을 제공하고, 로그인 상태에 따라 UI와 접근 권한을 제어한다.
- 즐겨찾기, 삭제, 다운로드 같은 라이브러리 상호작용을 사용자 권한에 맞춰 동작시키고 감사 가능한 이벤트 로그를 남길 수 있는 구조를 마련한다.

## 2. 현재 상태 요약
- `Library.js`는 `musicList` 상태와 더미 데이터를 결합하여 화면만 렌더링한다. 실제 데이터 로딩, 즐겨찾기 토글, 삭제 등은 전부 토스트 메시지를 띄우는 수준이다.
- 생성 페이지(`MusicGeneration`, `MusicConversion`)는 성공 시 임시 객체를 상태에 넣지만 영속 저장소가 없어 새로고침 시 데이터가 사라진다.
- 사용자 인증 기능이 없고, `MusicContext`는 단일 사용자 가정으로 동작한다.

## 3. 사용자 시나리오 (핵심 플로우)
1. **회원가입**: 사용자가 이메일/비밀번호로 가입 → displayName 입력 → Firestore `users` 문서 생성.
2. **로그인**: 인증 성공 후 토큰 기반 세션 유지 → 전역 컨텍스트에 사용자 정보 저장 → 라이브러리/생성 기능 접근 가능.
3. **음악 생성**: MusicGen API 호출 완료 → 결과 오디오를 Firebase Storage 업로드 → Firestore `tracks` 컬렉션에 메타데이터 + Storage URL 저장 → 라이브러리에서 즉시 반영.
4. **비트 생성**: 드럼 패턴 WAV export → Storage 업로드 → Firestore `beats` 문서 생성 → 라이브러리에 표시.
5. **라이브러리 상호작용**: 검색·필터는 Firestore 쿼리 or 클라이언트 필터링. 즐겨찾기 토글 시 `favorites` 서브컬렉션(또는 배열)을 업데이트. 삭제 시 Storage 파일 삭제 후 문서 soft delete.
6. **비로그인 접근**: 라이브러리 진입 시 로그인 유도 모달/리다이렉트, 생성 페이지는 읽기만 허용하거나 로그인 요구.

## 4. 데이터 모델 제안 (Cloud Firestore)

### 4.1 컬렉션 구조
| 컬렉션 | 문서 ID | 주요 필드 | 비고 |
| --- | --- | --- | --- |
| `users` | Firebase UID | `email`, `displayName`, `photoURL`, `createdAt`, `role` | role: `user`, `admin` |
| `tracks` | auto ID | `ownerId`, `title`, `genres`, `moods`, `durationSec`, `createdAt`, `audioPath`, `source` (`musicgen`/`upload`), `status` (`ready`/`processing`), `thumbnailPath?` | 생성 음악 |
| `beats` | auto ID | `ownerId`, `title`, `bpm`, `bars`, `pattern` (16×N bool 배열 or flattened string), `createdAt`, `audioPath`, `sourcePresetMeta` | 패드 블렌더 결과 |
| `favorites` | `${ownerId}` doc with subcollection `items` or top-level collection keyed by user | `targetType` (`track`/`beat`), `targetId`, `createdAt` | 단순화 위해 `users/{uid}/favorites/{targetId}` 구조 권장 |
| `activityLogs` (선택) | auto ID | `ownerId`, `type`, `targetId`, `timestamp`, `payload` | 감사/디버깅용 |

### 4.2 Firebase Storage 경로
- `audio/tracks/{uid}/{trackId}.wav`
- `audio/beats/{uid}/{beatId}.wav`
- (`thumbnails/…` 등 후속 확장 가능)

### 4.3 클라이언트 상태 매핑
- `MusicContext` 내 `library.musicList` → Firestore `tracks` + `beats` 통합 결과.
- 즐겨찾기: 로그인 사용자의 favorites 문서를 `onSnapshot`으로 구독하여 UI 반영.

## 5. Firebase Authentication 설계
- **방식**: 1차 릴리스는 이메일/비밀번호. 추후 Google OAuth 추가 가능 (UI/UX 고려하여 확장 포인트 마련).
- **가입 플로우**
  1. `createUserWithEmailAndPassword`
  2. `updateProfile`로 displayName 설정
  3. Firestore `users/{uid}` 문서 생성 (`setDoc` with merge)
- **로그인 플로우**: `signInWithEmailAndPassword` → `onAuthStateChanged`로 전역 상태 동기화.
- **세션 유지**: Firebase SDK 기본 persistence (`local`). CSR 환경으로 충분.
- **보호 라우팅**: React Router `PrivateRoute` 패턴 또는 `RequireAuth` 컴포넌트 도입.

## 6. 보안 규칙 (초안)
- `users/{uid}`: 읽기/쓰기 본인만 허용. Admin role은 전체 조회 가능.
- `tracks/{id}` & `beats/{id}`:
  - 읽기: 인증된 사용자이면서 `resource.data.ownerId == request.auth.uid` 또는 `resource.data.visibility == 'public'` (추후 공개 기능 고려).
  - 쓰기: 신규 작성 시 `request.auth.uid`가 ownerId와 일치해야 함.
  - 업데이트: ownerId 불변, 특정 필드만 수정 허용.
- `users/{uid}/favorites/{itemId}`: 본인만 읽기/쓰기. 존재 여부 검증으로 즐겨찾기 표시.
- Storage 규칙: `/audio/{type}/{uid}/**` 경로는 uid 본인만 읽기/쓰기. 다운로드 공유 시 공개 URL 생성 기능 사용.

## 7. 프론트엔드 통합 포인트
- `src/lib/firebase.js`: Firebase 앱 초기화, `auth`, `db`, `storage` export.
- `src/context/MusicContext.js` 개편: auth 상태 저장, Firestore 리스너 구독, 라이브러리 캐시 구성.
- 서비스 레이어:
  - `services/libraryApi.js` (신규): Firestore CRUD 래핑 (목록 조회, 즐겨찾기 토글, 삭제 등).
  - 기존 `musicApi.js`는 생성 요청 후 Firebase 저장 로직을 연결.
- UI 업데이트: Navbar에 로그인/회원가입 버튼, 사용자 아바타, 로그아웃 메뉴 추가. Library 페이지에서 실제 데이터 기반 렌더링.

## 8. 단계별 실행 로드맵
1. **환경 구성**: Firebase 프로젝트 생성, `.env.example` 업데이트, 초기화 모듈 작성.
2. **Auth UI & 로직**: 가입/로그인 폼 + 컨텍스트 리스너 + 보호 라우트.
3. **데이터 쓰기 파이프라인**: 생성/변환 완료 시 Firestore & Storage 반영.
4. **라이브러리 읽기**: Firestore에서 사용자 소유 `tracks`/`beats` 구독, 리스트 렌더링. 검색/정렬은 클라이언트부터 시작.
5. **즐겨찾기 및 액션**: favorites 컬렉션, 삭제(soft delete), 다운로드(Storage URL) 처리.
6. **보안 규칙/테스트**: 로컬 에뮬레이터 또는 시뮬레이터로 규칙 검증, 에러 처리 UX 개선.
7. **추가 고도화** (선택): 공유 링크, 공개 라이브러리, 소셜 로그인, 오프라인 캐싱.

## 9. 리스크와 대응
- **오디오 파일 용량**: Storage 비용/업로드 시간 → 워크플로에 업로드 진행 표시, 용량 제한.
- **실시간 동기화 지연**: 대용량 쿼리 대비 페이지네이션 or 시간순 정렬 필드 준비.
- **보안 규칙 실수**: 배포 전 시뮬레이터 테스트, 최소권한 원칙 준수.
- **API 실패 처리**: Firebase 연동 실패 시 롤백 전략 (예: Storage 업로드 성공 / Firestore 실패 → 업로드 삭제).

## 10. 다음 액션
1. Firebase 프로젝트 생성 및 자격 정보 확보.
2. 리포지터리에 `.env.example`에 Firebase 키 필드 추가.
3. `src/lib/firebase.js` 초기화 코드와 기본 SDK 셋업.
4. Auth 전역 상태를 설계하기 위해 `MusicContext` 구조 분석 (다음 단계 작업).

## 부록 A. MusicContext 개편 방향
- **현재 구조 요약**: 단일 `useReducer`로 생성/변환/라이브러리/UI 상태를 관리하며 사용자 개념이 없다. 라이브러리는 로컬 배열이며 즐겨찾기, 삭제 등은 단순 알림만 표시한다.
- **필요 변경 사항**
  - `auth` 슬라이스 추가: `user`, `authStatus`(`idle`/`loading`/`authenticated`/`error`), `error` 필드 등.
  - Firebase `onAuthStateChanged`를 구독하는 `useEffect`를 Provider에 도입하고, 결과를 `dispatch`하여 상태를 갱신.
  - 라이브러리 액션을 Firestore 연동과 연결하기 위해 `actions`에 async 함수를 허용하거나 별도 서비스 훅을 정의.
  - 생성/변환 완료 액션에서 Firestore 저장으로의 파이프를 연결하기 쉬운 구조(예: action 대신 thunk)로 점진적 리팩토링 고려.
- **단기 접근**
  1. `auth` 상태를 추가하고 Firebase Auth 변화 감지 후 `state.auth.user` 업데이트.
  2. 로그인 필요 페이지 보호를 위해 Context에서 제공할 `requireAuth` 헬퍼 또는 React Router 가드 구현.
  3. 라이브러리 데이터는 Auth 준비 이후 `useEffect`에서 사용자 ID 기반 Firestore 구독으로 채운다.
</file>

<file path="package.json">
{
  "name": "ai-music-frontend",
  "version": "0.1.0",
  "private": true,
  "dependencies": {
    "@emotion/react": "^11.14.0",
    "@emotion/styled": "^11.14.0",
    "@magenta/music": "1.23.1",
    "@mui/icons-material": "^7.1.1",
    "@mui/material": "^7.1.1",
    "@testing-library/dom": "^10.4.0",
    "@testing-library/jest-dom": "^6.6.3",
    "@testing-library/react": "^16.3.0",
    "@tensorflow/tfjs": "1.7.4",
    "buffer": "^6.0.3",
    "firebase": "^11.10.0",
    "react": "^19.1.0",
    "react-dom": "^19.1.0",
    "react-dropzone": "^14.3.8",
    "react-error-boundary": "^6.0.0",
    "react-router-dom": "^7.6.1",
    "react-scripts": "5.0.1",
    "tone": "14.7.58",
    "web-vitals": "^2.1.4"
  },
  "overrides": {
    "@tensorflow/tfjs": "1.7.4"
  },
  "scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build",
    "test": "react-scripts test",
    "eject": "react-scripts eject"
  },
  "eslintConfig": { "extends": ["react-app","react-app/jest"] },
  "browserslist": {
    "production": [">0.2%","not dead","not op_mini all"],
    "development": ["last 1 chrome version","last 1 firefox version","last 1 safari version"]
  }
}
</file>

<file path="PROJECT_DOCUMENTATION.md">
# AI 기반 배경음악 생성 및 변환 시스템 - 프론트엔드 문서

## 📋 프로젝트 개요

본 프로젝트는 AI를 활용하여 사용자가 원하는 분위기와 장르의 배경음악을 생성하고, 기존 음악을 새로운 스타일로 변환하는 웹 애플리케이션의 프론트엔드 부분입니다.

## 🏗️ 프로젝트 구조

### 전체 디렉토리 구조
```
ai-music-frontend/
├── public/
│   ├── index.html
│   └── favicon.ico
├── src/
│   ├── components/           # 재사용 가능한 컴포넌트
│   │   ├── common/          # 공통 UI 컴포넌트
│   │   │   ├── GenreSelector.js
│   │   │   └── MoodSelector.js
│   │   ├── layout/          # 레이아웃 컴포넌트
│   │   │   └── Navbar.js
│   │   └── music/           # 음악 관련 컴포넌트 (추후 확장)
│   ├── pages/               # 페이지 컴포넌트
│   │   ├── MusicGeneration.js
│   │   ├── MusicConversion.js
│   │   ├── ResultPage.js
│   │   └── Library.js
│   ├── context/             # 전역 상태 관리
│   │   └── MusicContext.js
│   ├── services/            # API 통신 서비스
│   │   └── musicApi.js
│   ├── utils/               # 유틸리티 함수
│   ├── hooks/               # 커스텀 훅 (추후 확장)
│   ├── App.js              # 메인 앱 컴포넌트
│   └── index.js            # 엔트리 포인트
├── UI_UX_DESIGN.md         # UI/UX 설계 문서
├── PROJECT_DOCUMENTATION.md # 이 문서
└── package.json
```

## 🎯 주요 기능

### 1. 음악 생성 (MusicGeneration.js)
- **장르 선택**: 최대 3개의 장르 선택 가능
- **분위기 키워드**: 최대 5개의 분위기 태그 선택
- **상세 설명**: 자유 텍스트로 원하는 음악 설명
- **음악 길이**: 30초~10분 사이 설정 가능
- **실시간 진행률**: AI 생성 과정 시각화

### 2. 음악 변환 (MusicConversion.js)
- **파일 업로드**: 드래그 앤 드롭 또는 클릭으로 파일 선택
- **미리 듣기**: 업로드된 원본 파일 재생 기능
- **변환 스타일**: 단일 장르 선택
- **변환 강도**: 1-5 스케일로 변환 정도 조절

### 3. 결과 페이지 (ResultPage.js)
- **음악 플레이어**: 생성/변환된 음악 재생
- **정보 표시**: 장르, 분위기, 생성 시간 등
- **액션 버튼**: 다운로드, 즐겨찾기, 라이브러리 추가
- **추가 행동**: 재생성, 공유 등

### 4. 라이브러리 (Library.js)
- **음악 목록**: 생성/변환된 모든 음악 관리
- **검색 및 필터**: 제목, 타입, 장르별 필터링
- **정렬**: 날짜, 제목, 길이, 즐겨찾기순 정렬
- **카드 UI**: 시각적으로 구조화된 음악 정보

## 🔧 기술 스택

### 프론트엔드 라이브러리
- **React 18**: 메인 UI 라이브러리
- **React Router DOM**: 클라이언트 사이드 라우팅
- **Material-UI (MUI)**: 디자인 시스템 및 컴포넌트
- **React Dropzone**: 파일 드래그 앤 드롭 기능

### 상태 관리
- **React Context + useReducer**: 전역 상태 관리
- **localStorage**: 클라이언트 사이드 데이터 저장 (추후 구현 예정)

### 스타일링
- **Material-UI Theme**: 일관된 디자인 시스템
- **CSS-in-JS**: Emotion 기반 스타일링
- **반응형 디자인**: 모바일/태블릿/데스크톱 대응

## 🎨 디자인 시스템

### 컬러 팔레트
- **Primary**: #6366F1 (인디고) - 메인 액션 버튼, 링크
- **Secondary**: #8B5CF6 (보라) - 보조 액션, 강조
- **Success**: #10B981 (초록) - 성공 메시지
- **Background**: #F8FAFC (연한 회색) - 페이지 배경

### 컴포넌트 원칙
- **재사용성**: 공통 UI 요소는 별도 컴포넌트화
- **접근성**: WCAG 2.1 가이드라인 준수
- **반응형**: 모든 화면 크기에서 최적화된 경험

## 📊 상태 관리 구조

### MusicContext 상태 구조
```javascript
{
  generation: {
    selectedGenres: [],      // 선택된 장르
    selectedMoods: [],       // 선택된 분위기
    description: '',         // 상세 설명
    duration: 120,          // 음악 길이 (초)
    isGenerating: false,    // 생성 중 여부
    generationProgress: 0   // 생성 진행률
  },
  conversion: {
    uploadedFile: null,     // 업로드된 파일
    targetGenre: '',        // 변환할 장르
    conversionIntensity: 3, // 변환 강도
    isConverting: false,    // 변환 중 여부
    conversionProgress: 0   // 변환 진행률
  },
  result: {
    generatedMusic: null,   // 생성된 음악 데이터
    convertedMusic: null,   // 변환된 음악 데이터
    isPlaying: false,       // 재생 상태
    currentTime: 0,         // 현재 재생 시간
    duration: 0             // 전체 길이
  },
  library: {
    musicList: [],          // 라이브러리 음악 목록
    sortBy: 'date',         // 정렬 기준
    filterBy: 'all'         // 필터 기준
  },
  ui: {
    currentPage: 'generate', // 현재 페이지
    notifications: [],       // 알림 목록
    loading: false,          // 로딩 상태
    error: null             // 에러 상태
  }
}
```

## 🔌 API 연동 구조

### 서비스 레이어 (musicApi.js)
- **생성 API**: 음악 생성 요청 및 진행률 모니터링
- **변환 API**: 파일 업로드 및 변환 진행률 추적
- **라이브러리 API**: 음악 목록 조회, 추가, 삭제
- **다운로드 API**: 음악 파일 다운로드

### API 연동 패턴
```javascript
// 예시: 음악 생성 API 호출
const handleGenerateMusic = async () => {
  try {
    actions.startGeneration();
    
    const result = await generateMusic(
      generationParams,
      (progress) => actions.updateGenerationProgress(progress)
    );
    
    actions.completeGeneration(result);
    navigate('/result');
    
  } catch (error) {
    actions.setError(error.message);
  }
};
```

## 🧩 주요 컴포넌트 설명

### 1. GenreSelector 컴포넌트
- **목적**: 장르 선택 UI 제공
- **기능**: 다중/단일 선택, 최대 선택 개수 제한
- **재사용성**: 생성 및 변환 페이지에서 공통 사용
- **Props**:
  - `selectedGenres`: 선택된 장르 배열
  - `onGenreChange`: 선택 변경 핸들러
  - `multiSelect`: 다중 선택 허용 여부
  - `maxSelection`: 최대 선택 개수

### 2. MoodSelector 컴포넌트
- **목적**: 분위기 키워드 선택 UI 제공
- **기능**: 이모지와 함께 표시, 진행률 시각화
- **특징**: 해시태그 스타일 디자인
- **Props**:
  - `selectedMoods`: 선택된 분위기 배열
  - `onMoodChange`: 선택 변경 핸들러
  - `maxSelection`: 최대 선택 개수

### 3. Navbar 컴포넌트
- **목적**: 전역 네비게이션 제공
- **기능**: 페이지 간 이동, 현재 페이지 표시
- **반응형**: 모바일에서는 아이콘만 표시
- **라우팅**: React Router와 연동

## 🔧 개발 시 고려사항

### 유지보수성
- **명확한 컴포넌트 구조**: 각 컴포넌트는 단일 책임 원칙 준수
- **타입 안정성**: PropTypes 또는 TypeScript 도입 고려 (추후)
- **코드 문서화**: JSDoc 스타일 주석 적극 활용
- **일관된 네이밍**: 직관적이고 설명적인 변수/함수명 사용

### 낮은 결합도 (Low Coupling)
- **Context 기반 상태 관리**: props drilling 방지
- **서비스 레이어 분리**: API 로직을 컴포넌트에서 분리
- **이벤트 기반 통신**: 컴포넌트 간 직접 참조 최소화
- **인터페이스 정의**: 명확한 props 인터페이스 정의

### 높은 응집도 (High Cohesion)
- **기능별 디렉토리 구조**: 관련 기능을 한 곳에 모음
- **도메인 중심 설계**: 음악 생성/변환/라이브러리 도메인 분리
- **컴포넌트 책임 분리**: UI, 비즈니스 로직, 데이터 관리 분리

### 확장성
- **모듈화된 구조**: 새로운 기능 추가 시 기존 코드 영향 최소화
- **설정 기반 개발**: 하드코딩된 값들을 설정으로 분리
- **플러그인 아키텍처**: 새로운 장르/분위기 쉽게 추가 가능
- **테마 시스템**: 다양한 디자인 테마 지원 가능

### 재사용성
- **공통 컴포넌트**: 버튼, 입력 필드, 카드 등 재사용 가능
- **훅 패턴**: 비즈니스 로직을 커스텀 훅으로 분리
- **유틸리티 함수**: 시간 포맷팅, 데이터 변환 등 공통 함수
- **스타일 토큰**: 일관된 디자인을 위한 토큰 시스템

## 🚀 추후 확장 계획

### 단기 개발 계획
1. **알림 시스템**: Toast 메시지 컴포넌트 구현
2. **로딩 상태**: 더 세밀한 로딩 상태 관리
3. **에러 처리**: 전역 에러 바운더리 구현
4. **접근성 개선**: 키보드 네비게이션, 스크린 리더 지원

### 중기 개발 계획
1. **고급 설정**: 템포, 악기, 음악 구조 설정
2. **미리보기 기능**: 생성 전 샘플 청취
3. **협업 기능**: 음악 공유 및 댓글
4. **분석 기능**: 사용자 선호도 분석

### 장기 개발 계획
1. **AI 모델 선택**: 다양한 AI 모델 중 선택 가능
2. **실시간 협업**: 여러 사용자가 함께 음악 제작
3. **모바일 앱**: React Native로 모바일 버전 개발
4. **플러그인 시스템**: 서드파티 기능 추가 지원

## 🧪 테스트 전략

### 단위 테스트
- **컴포넌트 테스트**: React Testing Library 사용
- **유틸리티 함수**: Jest 기반 단위 테스트
- **상태 관리**: Context 및 Reducer 테스트

### 통합 테스트
- **페이지 플로우**: 사용자 시나리오 기반 테스트
- **API 연동**: Mock Service Worker로 API 모킹
- **라우팅**: React Router 테스트

### E2E 테스트
- **전체 플로우**: Cypress 또는 Playwright 사용
- **크로스 브라우저**: 주요 브라우저 호환성 테스트
- **성능 테스트**: Core Web Vitals 측정

## 📦 배포 전략

### 개발 환경
- **개발 서버**: `npm start`로 로컬 개발
- **Hot Reload**: 실시간 코드 변경 반영
- **개발 도구**: React DevTools, Redux DevTools

### 스테이징 환경
- **빌드 테스트**: `npm run build`로 프로덕션 빌드 테스트
- **성능 최적화**: Bundle Analyzer로 번들 크기 최적화
- **브라우저 테스트**: 다양한 브라우저/기기에서 테스트

### 프로덕션 환경
- **정적 호스팅**: Vercel, Netlify 등 활용
- **CDN**: 전 세계 빠른 로딩 속도 보장
- **모니터링**: 에러 추적 및 성능 모니터링

## 🔒 보안 고려사항

### 클라이언트 보안
- **XSS 방지**: React의 기본 XSS 보호 활용
- **데이터 검증**: 사용자 입력 데이터 검증
- **민감 정보**: API 키 등 환경 변수로 관리

### API 보안
- **HTTPS**: 모든 API 통신 암호화
- **토큰 관리**: JWT 등 인증 토큰 안전 저장
- **CORS**: 적절한 CORS 정책 설정

## 📈 성능 최적화

### 렌더링 최적화
- **React.memo**: 불필요한 리렌더링 방지
- **useCallback/useMemo**: 함수 및 값 메모이제이션
- **코드 분할**: React.lazy로 컴포넌트 지연 로딩

### 네트워크 최적화
- **이미지 최적화**: WebP 포맷, 레이지 로딩
- **번들 최적화**: Tree Shaking, 코드 압축
- **캐싱**: 적절한 HTTP 캐싱 헤더 설정

## 🤝 기여 가이드라인

### 코딩 컨벤션
- **ESLint**: 코드 품질 검사
- **Prettier**: 코드 포맷팅 일관성
- **Git Convention**: Conventional Commits 사용

### Pull Request 과정
1. 기능 브랜치 생성
2. 코드 작성 및 테스트
3. PR 생성 및 코드 리뷰
4. 머지 전 CI/CD 통과 확인

---

이 문서는 프로젝트의 지속적인 발전과 함께 업데이트됩니다.
</file>

<file path="public/index.html">
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <link rel="icon" href="%PUBLIC_URL%/favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="theme-color" content="#000000" />
    <meta
      name="description"
      content="Web site created using create-react-app"
    />
    <link rel="apple-touch-icon" href="%PUBLIC_URL%/logo192.png" />
    <!--
      manifest.json provides metadata used when your web app is installed on a
      user's mobile device or desktop. See https://developers.google.com/web/fundamentals/web-app-manifest/
    -->
    <link rel="manifest" href="%PUBLIC_URL%/manifest.json" />
    <!--
      Notice the use of %PUBLIC_URL% in the tags above.
      It will be replaced with the URL of the `public` folder during the build.
      Only files inside the `public` folder can be referenced from the HTML.

      Unlike "/favicon.ico" or "favicon.ico", "%PUBLIC_URL%/favicon.ico" will
      work correctly both with client-side routing and a non-root public URL.
      Learn how to configure a non-root public URL by running `npm run build`.
    -->
    <title>React App</title>
  </head>
  <body>
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <div id="root"></div>
    <!--
      This HTML file is a template.
      If you open it directly in the browser, you will see an empty page.

      You can add webfonts, meta tags, or analytics to this file.
      The build step will place the bundled scripts into the <body> tag.

      To begin the development, run `npm start` or `yarn start`.
      To create a production bundle, use `npm run build` or `yarn build`.
    -->
  </body>
</html>
</file>

<file path="public/manifest.json">
{
  "short_name": "React App",
  "name": "Create React App Sample",
  "icons": [
    {
      "src": "favicon.ico",
      "sizes": "64x64 32x32 24x24 16x16",
      "type": "image/x-icon"
    },
    {
      "src": "logo192.png",
      "type": "image/png",
      "sizes": "192x192"
    },
    {
      "src": "logo512.png",
      "type": "image/png",
      "sizes": "512x512"
    }
  ],
  "start_url": ".",
  "display": "standalone",
  "theme_color": "#000000",
  "background_color": "#ffffff"
}
</file>

<file path="public/robots.txt">
# https://www.robotstxt.org/robotstxt.html
User-agent: *
Disallow:
</file>

<file path="README.md">
# AI Music Studio

React와 AI를 활용한 웹 기반 음악 생성 및 비트 메이킹 스튜디오입니다.

AI Music Studio는 사용자가 텍스트 프롬프트나 오디오 파일을 기반으로
새로운 음악을 생성하고, 내장된 AI 비트 메이커를 통해 독창적인 드럼
패턴을 만들 수 있는 웹 애플리케이션입니다.

![Project Screenshot](images/screenshot.png)

------------------------------------------------------------------------

## 주요 기능

-   **AI 음악 생성**
    -   장르, 분위기, 텍스트 설명을 조합하여 새로운 음악을 생성합니다.\
    -   오디오 파일을 첨부하여 기존 멜로디나 리듬을 기반으로 음악을
        생성할 수 있습니다.
-   **AI 비트 메이커 (Beat Maker)**
    -   Google Magenta의 `MusicVAE` 모델을 활용한 9트랙 드럼 시퀀서를
        제공합니다.\
    -   네 개의 코너 프리셋을 AI로 실시간 블렌딩하여 새로운 비트를
        탐색할 수 있습니다.\
    -   BPM 및 마디 조절, WAV 파일로 내보내기 기능을 지원합니다.
-   **음악 라이브러리**
    -   생성된 모든 음악을 한 곳에서 관리, 재생, 검색 및 필터링할 수
        있습니다.

------------------------------------------------------------------------

## 기술 스택

-   **프론트엔드**: React, React Router, Material-UI (MUI)\
-   **상태 관리**: React Context API\
-   **AI & 오디오**
    -   Hugging Face / Replicate: 텍스트 기반 음악 생성을 위한 백엔드
        API\
    -   @magenta/music & @tensorflow/tfjs: AI 비트 메이커의 핵심
        (MusicVAE)\
    -   Tone.js: 웹 오디오 재생 및 시퀀싱\
-   **백엔드**: Python (Flask), aistudio-music-api\
-   **API**: Papago API (텍스트 번역)

------------------------------------------------------------------------

## 시작하기

### 필수 요구사항

-   Node.js (v16 이상 권장)\
-   npm 또는 yarn\
-   Python 3

### 설치 및 실행

1.  **저장소 클론**

    ``` bash
    git clone https://github.com/your-username/your-repository.git
    cd your-repository
    ```

2.  **프론트엔드 설정** (새 터미널에서 실행)

    ``` bash
    # 의존성 설치
    npm install

    # 개발 서버 실행 (http://localhost:3000)
    npm start
    ```

3.  **백엔드 설정** (다른 새 터미널에서 실행)

    ``` bash
    cd ai-music-backend

    # 가상 환경 생성 및 활성화 (권장)
    python -m venv venv
    source venv/bin/activate  # macOS/Linux
    # venv\Scripts\activate    # Windows

    # 의존성 설치
    pip install -r requirements.txt

    # .env 파일 생성 및 API 키 설정
    # (PAPAGO_CLIENT_ID, PAPAGO_CLIENT_SECRET, REPLICATE_API_TOKEN 등)

    # 서버 실행 (http://localhost:5000)
    python server.py
    ```

이제 브라우저에서 `http://localhost:3000`으로 접속하여 애플리케이션을
사용할 수 있습니다.

------------------------------------------------------------------------

## 프로젝트 구조

이 프로젝트는 React 프론트엔드와 Python Flask 백엔드가 분리된 형태로 구성되어 있습니다.

    /
    ├── ai-music-backend/    # Python Flask 백엔드 서버
    │   ├── server.py        # 메인 API 서버 파일
    │   └── requirements.txt # 백엔드 의존성 목록
    │
    ├── public/              # 정적 파일 (HTML, 이미지 등)
    │
    └── src/                 # React 프론트엔드 소스 코드
        ├── components/      # 재사용 가능한 공용 컴포넌트
        │   ├── beat/        # 비트 메이커 관련 UI (패드, 그리드 등)
        │   └── common/      # 장르/분위기 선택 등 범용 UI
        │
        ├── context/         # 전역 상태 관리 (MusicContext)
        │
        ├── lib/             # 외부 라이브러리 래퍼 (Magenta.js, Tone.js)
        │   └── drumsVAE.js  # MusicVAE 핵심 로직
        │
        ├── pages/           # 페이지 단위 컴포넌트
        │   ├── MusicGeneration.js
        │   ├── MusicConversion.js (BeatMaker)
        │   └── Library.js
        │
        ├── services/        # API 통신 로직 (musicApi.js)
        │
        └── App.js           # 메인 애플리케이션 컴포넌트
</file>

<file path="src/App.css">
.App {
  text-align: center;
}

.App-logo {
  height: 40vmin;
  pointer-events: none;
}

@media (prefers-reduced-motion: no-preference) {
  .App-logo {
    animation: App-logo-spin infinite 20s linear;
  }
}

.App-header {
  background-color: #282c34;
  min-height: 100vh;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  font-size: calc(10px + 2vmin);
  color: white;
}

.App-link {
  color: #61dafb;
}

@keyframes App-logo-spin {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}
</file>

<file path="src/App.js">
import React from 'react';
import { BrowserRouter as Router, Routes, Route } from 'react-router-dom';
import { ThemeProvider, createTheme } from '@mui/material/styles';
import CssBaseline from '@mui/material/CssBaseline';
import Box from '@mui/material/Box';

// 페이지 및 컴포넌트
import Navbar from './components/layout/Navbar';
import MusicGeneration from './pages/MusicGeneration';
import MusicConversion from './pages/MusicConversion';
import ResultPage from './pages/ResultPage';
import Library from './pages/Library';
import AuthPage from './pages/Auth';
import ScoreToMusic from './pages/ScoreToMusic';
import RequireAuth from './components/common/RequireAuth';
import { MusicContextProvider } from './context/MusicContext';

// ✅ MUI 테마 설정
const theme = createTheme({
  palette: {
    mode: 'light',
    primary: { main: '#6366F1' },
    secondary: { main: '#8B5CF6' },
    success: { main: '#10B981' },
    warning: { main: '#F59E0B' },
    error: { main: '#EF4444' },
    background: {
      default: '#F8FAFC',
      paper: '#FFFFFF',
    },
    text: {
      primary: '#1E293B',
      secondary: '#64748B',
    },
  },
  typography: {
    fontFamily: '"Inter", "Roboto", "Helvetica", "Arial", sans-serif',
    h1: { fontSize: '2.5rem', fontWeight: 700 },
    h2: { fontSize: '2rem', fontWeight: 600 },
    h3: { fontSize: '1.5rem', fontWeight: 500 },
    body1: { fontSize: '1rem', fontWeight: 400 },
    caption: { fontSize: '0.875rem', fontWeight: 400 },
  },
  shape: { borderRadius: 8 },
  spacing: 8,
});

function App() {
  return (
    <ThemeProvider theme={theme}>
      <CssBaseline />
      <MusicContextProvider>
        <Router>
          <Box sx={{ display: 'flex', flexDirection: 'column', minHeight: '100vh' }}>
            {/* ✅ 모든 페이지에서 공통으로 보여줄 Navbar */}
            <Navbar />

            {/* ✅ 라우터로 각 페이지 연결 */}
            <Box component="main" sx={{ flexGrow: 1, bgcolor: 'background.default' }}>
              <Routes>
                {/* 기본 홈 (AI 음악 생성) */}
                <Route path="/" element={<MusicGeneration />} />
                <Route path="/generate" element={<MusicGeneration />} />

                {/* 음악 변환 페이지 */}
                <Route path="/convert" element={<MusicConversion />} />

                {/* 악보 → 음악 변환 페이지 */}
                <Route path="/score-to-midi" element={<ScoreToMusic />} />

                {/* 결과 페이지 */}
                <Route path="/result" element={<ResultPage />} />

                {/* 라이브러리 (로그인 필요) */}
                <Route
                  path="/library"
                  element={
                    <RequireAuth>
                      <Library />
                    </RequireAuth>
                  }
                />

                {/* 로그인/회원가입 */}
                <Route path="/auth" element={<AuthPage />} />

                {/* ✅ 예외 처리 (잘못된 주소 → 홈으로) */}
                <Route path="*" element={<MusicGeneration />} />
              </Routes>
            </Box>
          </Box>
        </Router>
      </MusicContextProvider>
    </ThemeProvider>
  );
}

export default App;
</file>

<file path="src/App.test.js">
import { render, screen } from '@testing-library/react';
import App from './App';

test('renders learn react link', () => {
  render(<App />);
  const linkElement = screen.getByText(/learn react/i);
  expect(linkElement).toBeInTheDocument();
});
</file>

<file path="src/components/beat/BeatGrid.jsx">
// src/components/beat/BeatGrid.jsx
import React from 'react';
import { Box } from '@mui/material';
import { PATTERN_STEPS, TRACKS } from './presets';

function labelOf(key) {
  switch (key) {
    case 'kick': return 'Kick';
    case 'snare': return 'Snare';
    case 'hatC': return 'Hat (C)';
    case 'hatO': return 'Hat (O)';
    case 'tomL': return 'Tom (L)';
    case 'tomM': return 'Tom (M)';
    case 'tomH': return 'Tom (H)';
    case 'crash': return 'Crash';
    case 'ride': return 'Ride';
    default: return key;
  }
}

/**
 * props:
 *  - pattern, currentStep, onToggle (필수)
 *  - fullWidth?: boolean           // 컨테이너 가로 100%
 *  - minCell?: number              // 각 스텝의 최소 너비(px)
 *  - gap?: number                  // 스텝 사이 간격(px)
 *  - labelWidth?: number           // 좌측 라벨 영역 폭(px)
 */
export default function BeatGrid({
  pattern,
  currentStep,
  onToggle,
  fullWidth = true,
  minCell = 36,
  gap = 6,
  labelWidth = 90,
  cellHeight = 28,
}) {
  const cellH = cellHeight;
  const gapPx = Number.isFinite(gap) ? gap : 6;
  const gridMinWidth = labelWidth + PATTERN_STEPS * (minCell + gapPx);

  return (
    <Box sx={{ width: fullWidth ? '100%' : 'auto', height: '100%', display: 'flex', flexDirection: 'column' }}>
      <Box
        sx={{
          display: 'grid',
          minWidth: `${gridMinWidth}px`,
          gridTemplateColumns: `${labelWidth}px repeat(${PATTERN_STEPS}, minmax(${minCell}px, 1fr))`,
          gap: { xs: '4px', md: `${gap}px` },
          alignItems: 'center',
          flex: 1,
          overflowX: 'auto',
          pb: 1,
        }}
      >
        {/* 헤더(1~16) */}
        <Box />
        {Array.from({ length: PATTERN_STEPS }).map((_, i) => (
          <Box key={`h${i}`} sx={{ textAlign: 'center', fontSize: { xs: 11, md: 12 }, color: '#9aa7b3' }}>
            {i + 1}
          </Box>
        ))}

        {/* 트랙 9줄 */}
        {TRACKS.map((trackName) => {
          const steps = Array.from({ length: PATTERN_STEPS }, (_, idx) => pattern[trackName]?.[idx] ?? false);
          return (
            <React.Fragment key={trackName}>
              <Box sx={{ color: '#ddd', fontWeight: 600, display: 'flex', alignItems: 'center', height: cellH }}>
                {labelOf(trackName)}
              </Box>

              {steps.map((on, step) => {
                const isNow = step === currentStep;
                return (
                  <Box
                    key={`${trackName}-${step}`}
                    onClick={() => onToggle(trackName, step)}
                    sx={{
                      cursor: 'pointer',
                      height: cellH,
                      borderRadius: 1,
                      border: '1px solid #333',
                      bgcolor: on ? (isNow ? '#2DD4BF' : '#1e8f7e') : (isNow ? '#333' : '#111'),
                      boxShadow: on ? '0 0 8px rgba(45,212,191,0.35)' : 'none',
                      transition: 'background-color .12s, box-shadow .12s',
                    }}
                  />
                );
              })}
            </React.Fragment>
          );
        })}
      </Box>
    </Box>
  );
}
</file>

<file path="src/components/beat/BlendPad.jsx">
// src/components/beat/BlendPad.jsx
import React, { useMemo } from 'react';
import { Box, Typography, FormControl, Select, MenuItem } from '@mui/material';
import { PRESETS } from './presets';

// corners prop은 { A: 'Rock 1', ... } 형태의 프리셋 이름 매핑입니다.
export default function BlendPad({ colors, corners, onChangeCorners, children, showTitle = true }) {
  const presetNames = useMemo(() => Object.keys(PRESETS), []);

  return (
    <Box sx={{ color: colors.text }}>
      {showTitle && (
        <Typography variant="h6" sx={{ color: colors.text, mb: 1 }}>
          패드 블렌딩
        </Typography>
      )}

      <Box
        sx={{
          display: 'grid',
          gap: 1,
          mb: 2,
          gridTemplateColumns: {
            xs: 'repeat(auto-fit, minmax(140px, 1fr))',
            sm: 'repeat(2, minmax(0, 1fr))',
          },
        }}
      >
        {['A', 'B', 'C', 'D'].map((k) => (
          <FormControl key={k} size="small" sx={{ minWidth: 0 }}>
            <Select
              value={corners?.[k] ?? 'Rock 1'}
              onChange={(e) => onChangeCorners?.(k, e.target.value)}
              sx={{
                color: colors.text,
                bgcolor: colors.cardBg,
                border: `1px solid ${colors.border}`,
              }}
            >
              {presetNames.map((name) => (
                <MenuItem key={name} value={name}>
                  {name}
                </MenuItem>
              ))}
            </Select>
          </FormControl>
        ))}
      </Box>

      {children}
    </Box>
  );
}
</file>

<file path="src/components/beat/BlendPadCanvas.jsx">
// src/components/beat/BlendPadCanvas.jsx

import React, { useCallback, useEffect, useRef, useState } from 'react';
import { useBeatPad } from '../../state/beatPadStore';
import { samplePathByDistance } from '../../hooks/usePathMode';

export default function BlendPadCanvas({ onBlend, disabled = false, pathRef: externalPathRef, onDrawingChange }) {
  const canvasRef = useRef(null);
  const internalPathRef = useRef([]);
  const pathRef = externalPathRef || internalPathRef;
  const { state, dispatch } = useBeatPad();
  const [dragging, setDragging] = useState(false);

  const getXY01 = useCallback((event) => {
    const canvas = canvasRef.current;
    if (!canvas) return { x: 0.5, y: 0.5 };
    const rect = canvas.getBoundingClientRect();
    const point = event.touches?.[0] ?? event;
    const x = (point.clientX - rect.left) / rect.width;
    const y = (point.clientY - rect.top) / rect.height;
    return {
      x: Math.max(0, Math.min(1, x)),
      y: Math.max(0, Math.min(1, y)),
    };
  }, []);

  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas || disabled) return;

    const handlePointerDown = (event) => {
      if (event.button === 2) return;
      setDragging(true);
      onDrawingChange?.(true);
      canvas.setPointerCapture?.(event.pointerId);
      const coords = getXY01(event);

      if (state.drawMode === 'PATH') {
        pathRef.current = [coords];
      } else {
        onBlend?.(coords.x, coords.y);
      }
      event.preventDefault();
    };

    const handlePointerMove = (event) => {
      if (!dragging) return;
      const coords = getXY01(event);
      if (state.drawMode === 'PATH') {
        pathRef.current.push(coords);
      } else {
        onBlend?.(coords.x, coords.y);
      }
    };

    const finalizePath = () => {
      const rawPath = pathRef.current || [];
      if (rawPath.length < 2) {
        dispatch({ type: 'RESET_PATH' });
        return;
      }

      let totalLength = 0;
      for (let i = 1; i < rawPath.length; i++) {
        const p1 = rawPath[i - 1];
        const p2 = rawPath[i];
        totalLength += Math.hypot(p2.x - p1.x, p2.y - p1.y);
      }

      const numPoints = Math.max(100, Math.floor(totalLength * 300));
      const smoothPath = [];
      for (let i = 0; i < numPoints; i++) {
        const t = numPoints === 1 ? 0 : i / (numPoints - 1);
        smoothPath.push(samplePathByDistance(rawPath, t));
      }

      dispatch({ type: 'SET_PATH', payload: smoothPath });
      pathRef.current = smoothPath;
    };

    const handlePointerEnd = (event) => {
      if (!dragging) return;
      setDragging(false);
      onDrawingChange?.(false);
      canvas.releasePointerCapture?.(event.pointerId);
      if (state.drawMode === 'PATH') {
        finalizePath();
      }
    };

    canvas.addEventListener('pointerdown', handlePointerDown, { passive: false });
    window.addEventListener('pointermove', handlePointerMove);
    window.addEventListener('pointerup', handlePointerEnd);
    window.addEventListener('pointercancel', handlePointerEnd);

    return () => {
      canvas.removeEventListener('pointerdown', handlePointerDown);
      window.removeEventListener('pointermove', handlePointerMove);
      window.removeEventListener('pointerup', handlePointerEnd);
      window.removeEventListener('pointercancel', handlePointerEnd);
    };
  }, [dispatch, dragging, getXY01, onBlend, state.drawMode, disabled, pathRef, onDrawingChange]);

  return (
    <canvas
      ref={canvasRef}
      style={{
        position: 'absolute',
        inset: 0,
        width: '100%',
        height: '100%',
        cursor: disabled ? 'not-allowed' : state.drawMode === 'PATH' ? 'crosshair' : 'pointer',
        touchAction: 'none',
        pointerEvents: disabled ? 'none' : 'auto',
      }}
    />
  );
}
</file>

<file path="src/components/beat/BlendPadGhostLayer.jsx">
import React, { useEffect, useRef } from "react";
import { useBeatPad } from "../../state/beatPadStore";
import { cellCache } from "../../lib/beatblender/cellCache";
import { drawMiniPattern } from "../../lib/beatblender/previewRender";
import { useCellGrid } from "../../hooks/useCellGrid";
import { encodeCorners, decodeAtPosition } from "../../lib/drumsVAE";

export default function BlendPadGhostLayer({ corners }) {
  const ref = useRef(null);
  const { state, dispatch } = useBeatPad();
  const { centerOf } = useCellGrid(state.grid.cols, state.grid.rows);

  // 캔버스 해상도 동기화
  useEffect(() => {
    const canvas = ref.current;
    if (!canvas) return;
    const ro = new ResizeObserver(() => {
      const { clientWidth, clientHeight } = canvas;
      if (canvas.width !== clientWidth || canvas.height !== clientHeight) {
        canvas.width = clientWidth || 1;
        canvas.height = clientHeight || 1;
        drawAll();
      }
    });
    ro.observe(canvas);
    return () => ro.disconnect();
    // eslint-disable-next-line
  }, []);

  const drawAll = () => {
    const canvas = ref.current; if (!canvas) return;
    const ctx = canvas.getContext("2d");
    const { width, height } = canvas;
    const { cols, rows } = state.grid;
    const cw = width / cols;
    const rh = height / rows;

    ctx.clearRect(0, 0, width, height);
    for (let r = 0; r < rows; r++) {
      for (let c = 0; c < cols; c++) {
        const idx = r * cols + c;
        const pattern = cellCache.get(state.cellCacheVersion, idx);
        if (!pattern) continue;
        drawMiniPattern(ctx, c * cw, r * rh, cw, rh, pattern, { alpha: 0.22, tracks: 9 });
      }
    }
  };

  // 인코딩 보장
  const ensureEncodings = async () => {
    if (state.cornerEncodings) return state.cornerEncodings;
    if (!corners) return null;
    const enc = await encodeCorners(corners);
    dispatch({ type: "SET_CORNERS", encodings: enc });
    return enc;
  };

  // 셀 캐시 천천히 채우기
  useEffect(() => {
    let cancelled = false;
    const { cols, rows } = state.grid;

    const work = async (i = 0) => {
      if (cancelled) return;
      const enc = await ensureEncodings();
      if (!enc) return;

      const total = cols * rows;
      const batch = 15;
      for (let k = 0; k < batch && i < total; k++, i++) {
        const r = Math.floor(i / cols);
        const c = i % cols;
        const idx = r * cols + c;
        if (!cellCache.get(state.cellCacheVersion, idx)) {
          const { x, y } = centerOf({ col: c, row: r });
          const pattern = await decodeAtPosition(enc, x, y, 1.1);
          if (pattern) cellCache.set(state.cellCacheVersion, idx, pattern);
        }
      }
      drawAll();
      if (i < total) requestAnimationFrame(() => work(i));
    };

    work();
    return () => { cancelled = true; };
    // eslint-disable-next-line
  }, [state.grid, state.cellCacheVersion, corners]);

  return <canvas ref={ref} className="blendpad-ghost" />;
}
</file>

<file path="src/components/beat/PadToolbar.jsx">
// src/components/beat/PadToolbar.jsx

import React from "react";
import { Button, ButtonGroup } from "@mui/material";
import { useBeatPad } from "../../state/beatPadStore";

const buttonStyles = {
  contained: {
    bgcolor: "#2DD4BF",
    color: "#0A0A0A",
    fontWeight: 600,
    "&:hover": { bgcolor: "#28bfa8" },
  },
  outlined: {
    borderColor: "#2DD4BF",
    color: "#2DD4BF",
    fontWeight: 600,
    "&:hover": {
      borderColor: "#2DD4BF",
      backgroundColor: "rgba(45, 212, 191, 0.1)",
    },
  },
};

export default function PadToolbar() {
  const { state, dispatch } = useBeatPad();

  const toggleDrawMode = () => {
    const nextMode = state.drawMode === "PATH" ? "DRAG" : "PATH";
    dispatch({ type: "SET_DRAW_MODE", payload: nextMode });
  };

  return (
    <ButtonGroup size="small" variant="outlined" sx={{ mb: 2 }}>
      <Button
        onClick={toggleDrawMode}
        variant={state.drawMode === "PATH" ? "contained" : "outlined"}
        sx={state.drawMode === "PATH" ? buttonStyles.contained : buttonStyles.outlined}
      >
        그리기 모드
      </Button>
    </ButtonGroup>
  );
}
</file>

<file path="src/components/beat/PathOverlay.jsx">
// src/components/beat/PathOverlay.jsx

import React, { useEffect, useRef } from 'react';
import { useBeatPad } from '../../state/beatPadStore';

export default function PathOverlay({ pathRef, isDrawing }) {
  const { state } = useBeatPad();
  const canvasRef = useRef(null);
  const rafRef = useRef(null);

  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;
    const ctx = canvas.getContext('2d');

    let lastDpr = 1;

    const ensureSize = () => {
      const rect = canvas.getBoundingClientRect();
      const dpr = window.devicePixelRatio || 1;
      const width = Math.max(1, Math.round(rect.width * dpr));
      const height = Math.max(1, Math.round(rect.height * dpr));

      if (width !== canvas.width || height !== canvas.height || dpr !== lastDpr) {
        canvas.width = width;
        canvas.height = height;
        lastDpr = dpr;
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      }
    };

    const draw = () => {
      ensureSize();
      const rect = canvas.getBoundingClientRect();
      const width = rect.width;
      const height = rect.height;

      ctx.clearRect(0, 0, width, height);

      const activePath = isDrawing ? pathRef?.current : state.path;
      if (activePath && activePath.length > 1) {
        ctx.save();
        ctx.lineWidth = 3;
        ctx.strokeStyle = '#2DD4BF';
        ctx.lineJoin = 'round';
        ctx.lineCap = 'round';
        ctx.globalAlpha = 0.85;

        ctx.beginPath();
        ctx.moveTo(activePath[0].x * width, activePath[0].y * height);
        for (let i = 1; i < activePath.length; i++) {
          ctx.lineTo(activePath[i].x * width, activePath[i].y * height);
        }
        ctx.stroke();

        const lastPoint = activePath[activePath.length - 1];
        ctx.beginPath();
        ctx.arc(lastPoint.x * width, lastPoint.y * height, 5, 0, Math.PI * 2);
        ctx.fillStyle = '#2DD4BF';
        ctx.fill();
        ctx.restore();
      }

      const puck = state.puckPosition;
      if (puck) {
        ctx.save();
        ctx.beginPath();
        ctx.arc(puck.x * width, puck.y * height, 8, 0, Math.PI * 2);
        ctx.fillStyle = '#FFFFFF';
        ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
        ctx.shadowBlur = 10;
        ctx.fill();
        ctx.restore();
      }

      rafRef.current = requestAnimationFrame(draw);
    };

    rafRef.current = requestAnimationFrame(draw);

    return () => {
      if (rafRef.current) cancelAnimationFrame(rafRef.current);
    };
  }, [isDrawing, pathRef, state.path, state.puckPosition]);

  return (
    <canvas
      ref={canvasRef}
      style={{
        position: 'absolute',
        top: 0,
        left: 0,
        width: '100%',
        height: '100%',
        pointerEvents: 'none',
        zIndex: 10,
      }}
    />
  );
}
</file>

<file path="src/components/beat/presets.js">
// src/components/beat/presets.js

export const TRACKS = [
  'kick', 'snare', 'hatClose', 'hatOpen', 
  'tomLow', 'tomMid', 'tomHigh', 'crash', 'ride'
];

export const PATTERN_STEPS = 32;

function fromBitmask(bitmaskArray = []) {
  const maskLength = bitmaskArray.length;
  const pattern = {};
  TRACKS.forEach(track => {
    pattern[track] = Array(PATTERN_STEPS).fill(false);
  });

  for (let i = 0; i < PATTERN_STEPS; i++) {
    const mask = maskLength
      ? (bitmaskArray[i] ?? bitmaskArray[i % maskLength] ?? 0)
      : 0;
    if ((mask & 1) > 0) pattern.kick[i] = true;
    if ((mask & 2) > 0) pattern.snare[i] = true;
    if ((mask & 4) > 0) pattern.hatClose[i] = true;
    if ((mask & 8) > 0) pattern.hatOpen[i] = true;
    if ((mask & 16) > 0) pattern.tomLow[i] = true;
    if ((mask & 32) > 0) pattern.tomMid[i] = true;
    if ((mask & 64) > 0) pattern.tomHigh[i] = true;
    if ((mask & 128) > 0) pattern.crash[i] = true;
    if ((mask & 256) > 0) pattern.ride[i] = true;
  }
  return pattern;
}

const B = (arr) => {
  const source = Array.isArray(arr) ? arr : [];
  const len = source.length;
  if (len === 0) return Array(PATTERN_STEPS).fill(false);
  return Array(PATTERN_STEPS).fill(false).map((_, i) => !!source[i % len]);
};

export const PRESETS = {
  // 32칸 데이터 중 앞 16칸만 사용됩니다.
  "Rock 1": fromBitmask([1, 0, 1, 0, 2, 0, 0, 0, 1, 0, 1, 0, 2, 0, 0, 0]),
  "Rock 2": fromBitmask([385, 0, 1, 0, 256, 0, 1, 1, 386, 0, 0, 1, 256, 0, 1, 0]),
  "Reggaeton": fromBitmask([257, 0, 0, 258, 1, 0, 258, 0, 1, 256, 256, 2, 1, 0, 258, 0]),
  "Breakbeat": fromBitmask([5, 0, 5, 0, 6, 0, 4, 2, 5, 2, 5, 0, 6, 0, 4, 0]),
  "Basic Backbeat": fromBitmask([5, 0, 4, 0, 7, 0, 4, 0, 5, 0, 4, 0, 7, 0, 4, 0]),
  "Boots & Cats": fromBitmask([1, 0, 4, 0, 2, 0, 4, 0, 1, 0, 4, 0, 2, 0, 4, 0]),
  "Pop Punk": fromBitmask([5, 4, 10, 5, 4, 5, 10, 4, 5, 4, 10, 5, 4, 5, 10, 4]),
  "Half Time": fromBitmask([5, 0, 4, 0, 4, 0, 5, 0, 6, 0, 4, 0, 4, 0, 5, 0]),
  "Bossa Half Time": fromBitmask([ 7, 0, 256, 0, 4, 0, 263, 0, 5, 0, 0, 0, 262, 0, 5, 0]),
  "Samba Full Time": fromBitmask([7, 256, 4, 263, 5, 0, 262, 5, 261, 0, 262, 5, 5, 258, 4, 261]),
  "Four on the floor": {
    kick: B([1,0,0,0, 1,0,0,0, 1,0,0,0, 1,0,0,0]),
    snare: B([0,0,0,0, 1,0,0,0, 0,0,0,0, 1,0,0,0]),
    hatClose: B([1,0,1,0, 1,0,1,0, 1,0,1,0, 1,0,1,0]),
    hatOpen: B([]), tomLow: B([]), tomMid: B([]), tomHigh: B([]), crash: B([]), ride: B([])
  },
  "Busy Hats": {
    kick: B([1,0,0,0, 0,0,1,0, 0,0,0,0, 1,0,0,0]),
    snare: B([0,0,0,0, 1,0,0,0, 0,0,0,0, 1,0,0,0]),
    hatClose: B([1,1,0,1, 1,1,0,1, 1,1,0,1, 1,1,0,1]),
    hatOpen: B([0,0,1,0, 0,0,1,0, 0,0,1,0, 0,0,1,0]),
    tomLow: B([]), tomMid: B([]), tomHigh: B([]), crash: B([]), ride: B([])
  },
  "Minimal": {
    kick: B([1,0,0,0, 0,0,0,0, 1,0,0,0, 0,0,0,0]),
    snare: B([]),
    hatClose: B([1,0,0,0, 1,0,0,0, 1,0,0,0, 1,0,0,0]),
    hatOpen: B([]), tomLow: B([]), tomMid: B([]), tomHigh: B([]), crash: B([]), ride: B([])
  },
};

export const clonePattern = (p) => {
  const newPattern = {};
  TRACKS.forEach(track => {
    newPattern[track] = p && p[track] ? [...p[track]] : B([]);
    if (newPattern[track].length < PATTERN_STEPS) {
      newPattern[track] = [
        ...newPattern[track],
        ...Array(PATTERN_STEPS - newPattern[track].length).fill(false),
      ];
    } else if (newPattern[track].length > PATTERN_STEPS) {
      newPattern[track] = newPattern[track].slice(0, PATTERN_STEPS);
    }
  });
  return newPattern;
};
</file>

<file path="src/components/beat/SampleKit.js">
// src/components/beat/SampleKit.js
import * as Tone from 'tone';

// CRA(react-scripts)에서 public 폴더는 루트로 서비스됨
const BASE = (process.env.PUBLIC_URL || '') + '/samples/505/';

export const SAMPLE_PATHS = {
  kick:  `${BASE}kick.mp3`,
  snare: `${BASE}snare.mp3`,
  hatC:  `${BASE}hat-close.mp3`,
  hatO:  `${BASE}hat-open.mp3`,
  tomL:  `${BASE}tom-low.mp3`,
  tomM:  `${BASE}tom-mid.mp3`,
  tomH:  `${BASE}tom-high.mp3`,
  crash: `${BASE}crash.mp3`,
  ride:  `${BASE}ride.mp3`,
};

export async function createKit({ skipToneStart = false } = {}) {
  if (!skipToneStart) {
    await Tone.start();
  }
  const gain = new Tone.Gain(0.9).toDestination();

  return new Promise((resolve, reject) => {
    const players = new Tone.Players(SAMPLE_PATHS, {
      onload: () => resolve({ players, gain }),
      onerror: (name) => reject(new Error(`Sample load failed: ${name}`)),
    }).connect(gain);
  });
}
</file>

<file path="src/components/beat/SimpleBlendPad.jsx">
// src/components/beat/SimpleBlendPad.jsx
import React, { useEffect, useRef, useState } from 'react';

export default function SimpleBlendPad({
  width = 420,
  height = 420,
  grid = 16,             // 16x16 격자선
  initial = { x: 0.5, y: 0.5 },
  onChange,              // (x01, y01) 콜백
}) {
  const canvasRef = useRef(null);
  const [pos, setPos] = useState(initial);
  const [dragging, setDragging] = useState(false);

  const draw = () => {
    const cvs = canvasRef.current;
    if (!cvs) return;
    const ctx = cvs.getContext('2d');
    const w = cvs.width;
    const h = cvs.height;

    // 배경
    ctx.clearRect(0, 0, w, h);
    // 은은한 배경 그라디언트(좌상↔우하)
    const grad = ctx.createLinearGradient(0, 0, w, h);
    grad.addColorStop(0, '#111826');  // 좌상
    grad.addColorStop(1, '#10211e');  // 우하
    ctx.fillStyle = grad;
    ctx.fillRect(0, 0, w, h);

    // 격자
    ctx.strokeStyle = 'rgba(255,255,255,0.08)';
    ctx.lineWidth = 1;
    const stepX = w / grid;
    const stepY = h / grid;
    for (let i = 0; i <= grid; i++) {
      ctx.beginPath();
      ctx.moveTo(i * stepX + 0.5, 0);
      ctx.lineTo(i * stepX + 0.5, h);
      ctx.stroke();
    }
    for (let j = 0; j <= grid; j++) {
      ctx.beginPath();
      ctx.moveTo(0, j * stepY + 0.5);
      ctx.lineTo(w, j * stepY + 0.5);
      ctx.stroke();
    }

    // 퍽
    const px = pos.x * w;
    const py = pos.y * h;
    ctx.beginPath();
    ctx.arc(px, py, 10, 0, Math.PI * 2);
    ctx.fillStyle = '#2DD4BF';
    ctx.fill();

    // 교차선
    ctx.strokeStyle = 'rgba(45, 212, 191, 0.25)';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(px, 0);
    ctx.lineTo(px, h);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(0, py);
    ctx.lineTo(w, py);
    ctx.stroke();
  };

  useEffect(draw, [pos, width, height, grid]);

  const getXY01 = (e) => {
    const rect = e.currentTarget.getBoundingClientRect();
    const x = Math.min(Math.max((e.clientX - rect.left) / rect.width, 0), 1);
    const y = Math.min(Math.max((e.clientY - rect.top) / rect.height, 0), 1);
    return { x, y };
  };

  const start = (e) => {
    setDragging(true);
    const p = getXY01(e);
    setPos(p);
    onChange?.(p.x, p.y);
  };
  const move = (e) => {
    if (!dragging) return;
    const p = getXY01(e);
    setPos(p);
    onChange?.(p.x, p.y);
  };
  const end = () => setDragging(false);

  return (
    <canvas
      ref={canvasRef}
      width={width}
      height={height}
      style={{
        width,
        height,
        borderRadius: 16,
        border: '1px solid #333',
        display: 'block',
        background: '#0b0b0b',
        boxShadow: 'inset 0 0 0 1px rgba(255,255,255,0.02)',
        cursor: 'crosshair',
      }}
      onMouseDown={start}
      onMouseMove={move}
      onMouseUp={end}
      onMouseLeave={end}
    />
  );
}
</file>

<file path="src/components/beat/TransportBar.jsx">
// src/components/beat/TransportBar.jsx
import React, { useEffect, useMemo, useState } from 'react';
import { Box, Button, IconButton, Stack, TextField, Tooltip, Typography } from '@mui/material';
import PlayArrowIcon from '@mui/icons-material/PlayArrow';
import StopIcon from '@mui/icons-material/Stop';
import DeleteSweepIcon from '@mui/icons-material/DeleteSweep';
import DownloadIcon from '@mui/icons-material/Download';

export default function TransportBar(props) {
  const {
    value,
    bpm: bpmProp,
    onChangeBpm,
    onPlay,
    onStop,
    onClear,
    onExport,
    busy = false,
    busyMsg = '',
  } = props;
  
  const colors = {
    accent: '#2DD4BF',
    background: '#0A0A0A',
    cardBg: '#1A1A1A',
    border: '#333333',
    text: '#FFFFFF',
    textLight: '#CCCCCC',
    shadow: 'rgba(45, 212, 191, 0.3)',
    // 변경점 1: 정지 버튼에 사용할 빨간색 추가
    danger: '#EF5350'
  };

  const initialBpm = useMemo(() => {
    if (typeof value?.bpm === 'number') return value.bpm;
    if (typeof bpmProp === 'number') return bpmProp;
    return 60;
  }, [value?.bpm, bpmProp]);

  const [bpmLocal, setBpmLocal] = useState(String(initialBpm));

  useEffect(() => setBpmLocal(String(initialBpm)), [initialBpm]);

  const commitBpm = (nextValue) => {
    const parsed = Number(nextValue);
    const clamped = Number.isNaN(parsed)
      ? initialBpm
      : Math.max(40, Math.min(240, parsed));
    setBpmLocal(String(clamped));
    onChangeBpm?.(clamped);
  };

  const handleBpmChange = (e) => {
    const { value } = e.target;
    if (/^\d*$/.test(value)) {
      setBpmLocal(value);
    }
  };

  const handleBpmBlur = () => {
    if (bpmLocal === '') {
      commitBpm(initialBpm);
      return;
    }
    commitBpm(bpmLocal);
  };

  return (
    <Box sx={{ display: 'flex', alignItems: 'center', gap: 1.5, flexWrap: 'wrap' }}>
      <Stack direction="row" spacing={1} alignItems="center" sx={{ mr: 1 }}>
        <Tooltip title="재생">
          <span>
            <IconButton 
              color="primary" 
              onClick={onPlay} 
              disabled={busy} 
              size="large"
              sx={{ color: colors.accent, '&:hover': { backgroundColor: 'rgba(45, 212, 191, 0.1)' } }}
            >
              <PlayArrowIcon fontSize="large" />
            </IconButton>
          </span>
        </Tooltip>
        <Tooltip title="정지">
          <span>
            {/* 변경점 1: 정지 버튼 색상을 빨간색으로 변경 */}
            <IconButton 
              onClick={onStop} 
              disabled={busy} 
              size="large"
              sx={{ color: colors.danger, '&:hover': { backgroundColor: 'rgba(239, 83, 80, 0.1)' } }}
            >
              <StopIcon fontSize="large" />
            </IconButton>
          </span>
        </Tooltip>
        <Tooltip title="초기화">
          <span>
            <IconButton 
              onClick={onClear} 
              disabled={busy} 
              size="large"
              sx={{ color: colors.textLight, '&:hover': { backgroundColor: 'rgba(255, 255, 255, 0.1)' } }}
            >
              <DeleteSweepIcon fontSize="large" />
            </IconButton>
          </span>
        </Tooltip>
      </Stack>

      <Stack direction="row" spacing={1.5} alignItems="center">
        <TextField
          label="BPM"
          type="text"
          value={bpmLocal}
          onChange={handleBpmChange}
          onBlur={handleBpmBlur}
          inputProps={{ inputMode: 'numeric', pattern: '\\d*' }}
          sx={{ 
            width: 120,
            '& .MuiInputBase-root': { bgcolor: '#111', color: colors.text, borderRadius: 2 },
            '& .MuiOutlinedInput-notchedOutline': { borderColor: colors.border },
            '& .MuiInputLabel-root': { color: colors.textLight },
            '&.Mui-focused .MuiInputLabel-root': { color: colors.accent },
          }}
          disabled={busy}
        />
      </Stack>

      <Stack direction="row" spacing={1.5} sx={{ ml: 'auto' }}>
        <Button
          variant="outlined"
          startIcon={<DownloadIcon />}
          onClick={onExport}
          disabled={busy}
          size="large"
          sx={{
            borderColor: colors.accent,
            color: colors.accent,
            '&:hover': {
              borderColor: colors.accent,
              backgroundColor: 'rgba(45, 212, 191, 0.1)'
            }
          }}
        >
          {/* 변경점 2: '(WAV)' 텍스트 제거 */}
          다운로드
        </Button>
      </Stack>

      {busy ? (
        <Typography variant="body2" sx={{ ml: 2, opacity: 0.8 }}>
          {busyMsg || '처리 중...'}
        </Typography>
      ) : null}
    </Box>
  );
}
</file>

<file path="src/components/common/AudioWaveform.js">
import React, { useEffect, useState } from 'react';
import { Box } from '@mui/material';

const AudioWaveform = ({ 
  isPlaying = false, 
  progress = 0, 
  height = 80, 
  barCount = 50,
  color = '#8B5CF6'
}) => {
  const [bars, setBars] = useState([]);

  // 검은색 배경에 에메랄드 테마
  const colors = {
    primary: '#50E3C2',           // 에메랄드 (Emerald)
    secondary: '#40D9B8',         // 연한 에메랄드
    accent: '#2DD4BF',            // 터콰이즈 (Teal)
  };

  useEffect(() => {
    // 랜덤한 높이의 바들을 생성
    const newBars = Array.from({ length: barCount }, () => Math.random() * 0.8 + 0.2);
    setBars(newBars);
  }, [barCount]);

  useEffect(() => {
    if (!isPlaying) return;

    const interval = setInterval(() => {
      setBars(prev => prev.map(() => Math.random() * 0.8 + 0.2));
    }, 150);

    return () => clearInterval(interval);
  }, [isPlaying]);

  const progressBarIndex = Math.floor((progress / 100) * bars.length);

  return (
    <Box
      sx={{
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center',
        gap: '2px',
        height: height,
        padding: '10px',
        bgcolor: 'rgba(255, 255, 255, 0.05)',
        borderRadius: 2,
        overflow: 'hidden'
      }}
    >
      {bars.map((barHeight, index) => (
        <Box
          key={index}
                      sx={{
              width: '3px',
              bgcolor: isPlaying && index <= progressBarIndex ? colors.primary : colors.secondary,
              borderRadius: '2px',
              transition: 'all 0.1s ease',
              height: `${barHeight * height * 0.8}px`,
              opacity: isPlaying && index <= progressBarIndex ? 1 : 0.6
            }}
          onClick={() => {
            // 클릭 시 해당 위치로 이동하는 로직 추가 가능
          }}
        />
      ))}
    </Box>
  );
};

export default AudioWaveform;
</file>

<file path="src/components/common/GenreCardSelector.js">
import React, { useState } from 'react';
import {
  Box,
  Typography,
  Card,
  CardContent,
  Grid
} from '@mui/material';

// 장르 옵션들 (실제 이미지 파일 경로 포함)
export const GENRE_CARD_OPTIONS = [
  { 
    id: 'classic', 
    label: '클래식', 
    gradient: 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)',
    image: '/images/genres/classic.jpg', // 실제 이미지 경로
    fallbackIcon: '🎼'
  },
  { 
    id: 'edm', 
    label: 'EDM', 
    gradient: 'linear-gradient(135deg, #f093fb 0%, #f5576c 100%)',
    image: '/images/genres/edm.jpg',
    fallbackIcon: '🎛️'
  },
  { 
    id: 'citypop', 
    label: 'City pop', 
    gradient: 'linear-gradient(135deg, #4facfe 0%, #00f2fe 100%)',
    image: '/images/genres/citypop.jpg',
    fallbackIcon: '🌃'
  },
  { 
    id: 'jazz', 
    label: '재즈', 
    gradient: 'linear-gradient(135deg, #43e97b 0%, #38f9d7 100%)',
    image: '/images/genres/jazz.jpg',
    fallbackIcon: '🎷'
  },
  { 
    id: 'lofi', 
    label: 'Lo-Fi', 
    gradient: 'linear-gradient(135deg, #ffecd2 0%, #fcb69f 100%)',
    image: '/images/genres/lofi.jpg',
    fallbackIcon: '🎧'
  }
];
  
// 이미지 컴포넌트 (이미지 로드 실패 시 fallback)
const GenreImage = ({ genre }) => {
  const [imageError, setImageError] = useState(false);
  
  if (imageError) {
    // 이미지 로드 실패 시 그라디언트와 아이콘 표시
    return (
      <Box
        sx={{
          height: 140, // 더 큰 높이
          background: genre.gradient,
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'center',
          position: 'relative',
          overflow: 'hidden'
        }}
      >
        <Typography
          sx={{
            fontSize: '3rem', // 더 큰 아이콘
            filter: 'drop-shadow(0 2px 4px rgba(0,0,0,0.3))'
          }}
        >
          {genre.fallbackIcon}
        </Typography>
      </Box>
    );
  }
  
  return (
    <Box
      sx={{
        height: 140, // 더 큰 높이
        position: 'relative',
        overflow: 'hidden',
        background: genre.gradient
      }}
    >
      <img
        src={genre.image}
        alt={genre.label}
        onError={() => setImageError(true)}
        style={{
          width: '100%',
          height: '100%',
          objectFit: 'cover',
          position: 'absolute',
          top: 0,
          left: 0
        }}
      />
    </Box>
  );
};

const GenreCardSelector = ({  
selectedGenres = [], 
onGenreChange, 
maxSelection = 1
}) => {
  const colors = {
    cardBg: '#1A1A1A',
    text: '#FFFFFF',
    border: '#333333',
    accent: '#FFD700'
  };

  const handleGenreClick = (genreId) => {
    let newGenres;
    
    if (selectedGenres.includes(genreId)) {
      newGenres = selectedGenres.filter(id => id !== genreId);
    } else {
      if (maxSelection === 1) {
        newGenres = [genreId];
      } else {
        if (selectedGenres.length < maxSelection) {
          newGenres = [...selectedGenres, genreId];
        } else {
          return;
        }
      }
    }
    
    onGenreChange(newGenres);
  };

  return (
    <Grid container spacing={3}> {/* spacing 증가 */}
      {GENRE_CARD_OPTIONS.map((genre) => (
        <Grid item xs={12} sm={6} md={6} key={genre.id}> {/* 더 넓은 그리드 크기 */}
          <Card
            onClick={() => handleGenreClick(genre.id)}
            sx={{
              cursor: 'pointer',
              borderRadius: 4, // 더 둥근 모서리
              overflow: 'hidden',
              border: selectedGenres.includes(genre.id) 
                ? `3px solid ${colors.accent}` 
                : 'none', // 선택 안된 카드는 테두리 없음
              outline: 'none', // 아웃라인도 제거
              boxShadow: selectedGenres.includes(genre.id) ? undefined : 'none', // 선택 안된 카드는 그림자도 제거
              transition: 'all 0.3s ease-in-out',
              '&:hover': {
                transform: 'translateY(-6px)',
                boxShadow: `0 12px 35px rgba(255, 215, 0, 0.4)`
              },
              position: 'relative',
              height: '100%' // 카드 전체 높이 사용
            }}
          >
            {/* 배경 이미지 */}
            <Box sx={{ position: 'relative' }}>
              <GenreImage genre={genre} />
              
              {/* 선택된 경우 오버레이 */}
              {selectedGenres.includes(genre.id) && (
                <Box
                  sx={{
                    position: 'absolute',
                    top: 0,
                    left: 0,
                    right: 0,
                    bottom: 0,
                    bgcolor: 'rgba(255, 215, 0, 0.2)',
                    display: 'flex',
                    alignItems: 'center',
                    justifyContent: 'center'
                  }}
                >
                  <Box
                    sx={{
                      width: 32, // 더 큰 체크마크
                      height: 32,
                      borderRadius: '50%',
                      bgcolor: colors.accent,
                      display: 'flex',
                      alignItems: 'center',
                      justifyContent: 'center',
                      color: '#000000',
                      fontWeight: 'bold',
                      fontSize: '1.2rem'
                    }}
                  >
                    ✓
                  </Box>
                </Box>
              )}
            </Box>
            
            {/* 장르 이름 */}
            <CardContent 
              sx={{ 
                p: 2.5, // 더 큰 패딩
                bgcolor: colors.cardBg,
                '&:last-child': { pb: 2.5 },
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center',
                height: 80, // 더 큰 텍스트 영역
                border: 'none', // 테두리 제거
                borderTop: 'none' // 상단 테두리도 제거
              }}
            >
              <Typography
                variant="h6" // 더 큰 텍스트
                sx={{
                  color: colors.text,
                  fontWeight: 600,
                  textAlign: 'center',
                  fontSize: '1.1rem'
                }}
              >
                {genre.label}
              </Typography>
            </CardContent>
          </Card>
        </Grid>
      ))}
    </Grid>
  );
};

export default GenreCardSelector;
</file>

<file path="src/components/common/GenreSelector.js">
import React from 'react';
import {
  Box,
  Typography,
  Chip,
  Alert
} from '@mui/material';

// 장르 옵션들
export const GENRE_OPTIONS = [
  { id: 'classic', label: '클래식' },
  { id: 'edm', label: 'EDM' },
  { id: 'citypop', label: 'City pop' },
  { id: 'jazz', label: '재즈' },
  { id: 'lofi', label: 'Lo-Fi' }
];

const GenreSelector = ({ 
  selectedGenres = [], 
  onGenreChange, 
  maxSelection = 1,  // 하나만 선택 가능
  title = "장르 선택" 
}) => {
  // 검은색 배경에 에메랄드 테마  
  const colors = {
    background: '#0A0A0A',         // 검은색 배경
    cardBg: '#1A1A1A',            // 어두운 카드 배경
    primary: '#50E3C2',           // 에메랄드 (Emerald)
    secondary: '#40D9B8',         // 연한 에메랄드
    accent: '#2DD4BF',            // 터콰이즈 (Teal)
    text: '#FFFFFF',              // 흰색 텍스트
    textLight: '#CCCCCC',         // 연한 회색 텍스트
    border: '#333333',            // 어두운 테두리
    shadow: 'rgba(80, 227, 194, 0.3)' // 에메랄드 그림자
  };

  const handleGenreClick = (genreId) => {
    // 장르는 하나만 선택 가능
    const newGenres = selectedGenres.includes(genreId) ? [] : [genreId];
    onGenreChange(newGenres);
  };

  return (
    <Box>
      <Box sx={{ display: 'flex', flexWrap: 'wrap', gap: 1.5 }}>
        {GENRE_OPTIONS.map((genre) => (
          <Chip
            key={genre.id}
            label={genre.label}
            onClick={() => handleGenreClick(genre.id)}
            sx={{
              height: 42,
              fontSize: '0.9rem',
              fontWeight: 600,
              borderRadius: '12px',
              color: selectedGenres.includes(genre.id) ? colors.background : colors.text,
              bgcolor: selectedGenres.includes(genre.id) ? colors.primary : 'transparent',
              borderColor: selectedGenres.includes(genre.id) ? colors.primary : colors.border,
              '&:hover': {
                bgcolor: selectedGenres.includes(genre.id) ? colors.secondary : colors.cardBg,
                borderColor: colors.primary
              },
              transition: 'all 0.3s ease-in-out',
            }}
          />
        ))}
      </Box>
    </Box>
  );
};

export default GenreSelector;
</file>

<file path="src/components/common/MoodSelector.js">
import React from 'react';
import {
  Box,
  Typography,
  Chip,
  Alert
} from '@mui/material';

// 분위기 옵션들
export const MOOD_OPTIONS = [
  { id: 'happy', label: '행복한' },
  { id: 'sad', label: '슬픈' },
  { id: 'energetic', label: '활기찬' },
  { id: 'calm', label: '차분한' },
  { id: 'romantic', label: '로맨틱한' },
  { id: 'peaceful', label: '평화로운' },
  { id: 'dark', label: '어두운' },
  { id: 'uplifting', label: '희망적인' },
  { id: 'melancholic', label: '우울한' },
  { id: 'playful', label: '장난스러운' },
  { id: 'intense', label: '강렬한' },
  { id: 'dreamy', label: '몽환적인' }
];

const MoodSelector = ({ 
  selectedMoods = [], 
  onMoodChange, 
  maxSelection = 3,  // 3개까지 선택 가능
  title = "분위기 선택" 
}) => {
  // 검은색 배경에 에메랄드 테마
  const colors = {
    background: '#0A0A0A',         // 검은색 배경
    cardBg: '#1A1A1A',            // 어두운 카드 배경
    primary: '#50E3C2',           // 에메랄드 (Emerald)
    secondary: '#40D9B8',         // 연한 에메랄드
    accent: '#2DD4BF',            // 터콰이즈 (Teal)
    text: '#FFFFFF',              // 흰색 텍스트
    textLight: '#CCCCCC',         // 연한 회색 텍스트
    border: '#333333',            // 어두운 테두리
    shadow: 'rgba(80, 227, 194, 0.3)' // 에메랄드 그림자
  };

  const handleMoodClick = (moodId) => {
    let newMoods;
    
    if (selectedMoods.includes(moodId)) {
      newMoods = selectedMoods.filter(id => id !== moodId);
    } else {
      if (selectedMoods.length < maxSelection) {
        newMoods = [...selectedMoods, moodId];
      } else {
        return;
      }
    }
    
    onMoodChange(newMoods);
  };

  return (
    <Box>
      <Box sx={{ display: 'flex', flexWrap: 'wrap', gap: 1.5 }}>
        {MOOD_OPTIONS.map((mood) => (
          <Chip
            key={mood.id}
            label={mood.label}
            onClick={() => handleMoodClick(mood.id)}
            sx={{
              height: 42,
              fontSize: '0.9rem',
              fontWeight: 600,
              borderRadius: '20px',  
              bgcolor: selectedMoods.includes(mood.id) ? colors.primary : colors.cardBg,
              color: selectedMoods.includes(mood.id) ? '#FFFFFF' : colors.textLight,
              border: `2px solid ${selectedMoods.includes(mood.id) ? colors.primary : colors.border}`,
              '&:hover': {
                bgcolor: selectedMoods.includes(mood.id) ? colors.accent : colors.cardBg,
                color: '#FFFFFF',
                borderColor: selectedMoods.includes(mood.id) ? colors.accent : colors.border,
                transform: 'translateY(-2px)',
                boxShadow: `0 6px 16px ${colors.shadow}`
              },
              transition: 'all 0.3s ease-in-out',
            }}
          />
        ))}
      </Box>

      {selectedMoods.length === maxSelection && (
        <Alert 
          severity="info" 
          sx={{ 
            mt: 2,
            bgcolor: colors.primary,
            border: `1px solid ${colors.border}`,
            color: '#FFFFFF',
            '& .MuiAlert-icon': {
              color: '#FFFFFF'
            }
          }}
        >
          최대 {maxSelection}개의 분위기를 선택했습니다. 다른 분위기를 선택하려면 기존 선택을 해제해주세요.
        </Alert>
      )}
    </Box>
  );
};

export default MoodSelector;
</file>

<file path="src/components/common/RequireAuth.jsx">
import React from 'react';
import { Navigate, useLocation } from 'react-router-dom';
import { Box, CircularProgress, Typography } from '@mui/material';

import { useMusicContext } from '../../context/MusicContext';

export default function RequireAuth({ children }) {
  const {
    state: {
      auth: { user, status },
    },
  } = useMusicContext();
  const location = useLocation();

  if (status === 'loading' || status === 'idle') {
    return (
      <Box
        sx={{
          minHeight: '80vh',
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'center',
          flexDirection: 'column',
          gap: 2,
          bgcolor: '#050505',
        }}
      >
        <CircularProgress size={36} sx={{ color: '#2DD4BF' }} />
        <Typography sx={{ color: '#8FA3B5', fontWeight: 500 }}>
          접속 상태를 확인하고 있어요...
        </Typography>
      </Box>
    );
  }

  if (!user) {
    return <Navigate to="/auth" replace state={{ from: location.pathname }} />;
  }

  return children;
}
</file>

<file path="src/components/layout/Navbar.js">
// src/components/layout/Navbar.js
import React from 'react';
import { 
  AppBar, 
  Toolbar, 
  Typography, 
  Button, 
  Box,
  Container,
  IconButton
} from '@mui/material';
import { Menu } from '@mui/icons-material';
import { useNavigate } from 'react-router-dom';
import { useMusicContext } from '../../context/MusicContext';

const colors = {
  background: '#0A0A0A',
  cardBg: '#1A1A1A',
  primary: '#50E3C2',
  secondary: '#40D9B8',
  accent: '#2DD4BF',
  text: '#FFFFFF',
  textLight: '#CCCCCC',
  border: '#333333',
  shadow: 'rgba(80, 227, 194, 0.3)'
};

const Navbar = () => {
  const navigate = useNavigate();
  const { state, actions } = useMusicContext();
  const auth = state.auth;
  const isAuthed = Boolean(auth.user);

  const handleNavigation = (path) => {
    navigate(path);
  };

  const handleSignOut = async () => {
    try {
      await actions.signOut();
    } catch (error) {
      console.error(error);
    }
  };

  return (
    <AppBar 
      position="sticky" 
      elevation={0}
      sx={{
        bgcolor: colors.cardBg,
        borderBottom: `1px solid ${colors.accent}`,
      }}
    >
      <Container maxWidth="xl">
        <Toolbar 
          disableGutters
          sx={{
            minHeight: { xs: '64px', md: '80px' },
            justifyContent: 'space-between'
          }}
        >
          {/* 로고 */}
          <Box 
            sx={{ display: 'flex', alignItems: 'center', cursor: 'pointer' }}
            onClick={() => handleNavigation('/')}
          >
            <Typography
              variant="h6"
              component="div"
              sx={{
                fontWeight: 600,
                color: colors.text,
                fontSize: { xs: '1.2rem', md: '1.5rem' }
              }}
            >
              AI Music Studio
            </Typography>
          </Box>

          {/* 데스크탑 메뉴 */}
          <Box sx={{ display: { xs: 'none', md: 'flex' }, gap: 1 }}>
            <Button
              onClick={() => handleNavigation('/generate')}
              sx={{
                color: colors.text,
                fontWeight: 500,
                textTransform: 'none',
                px: 3,
                py: 1,
                borderRadius: 2,
                '&:hover': { bgcolor: colors.background, color: colors.accent }
              }}
            >
              음악 생성
            </Button>

            <Button
              onClick={() => handleNavigation('/convert')}
              sx={{
                color: colors.text,
                fontWeight: 500,
                textTransform: 'none',
                px: 3,
                py: 1,
                borderRadius: 2,
                '&:hover': { bgcolor: colors.background, color: colors.accent }
              }}
            >
              비트 만들기
            </Button>

            <Button
              onClick={() => handleNavigation('/score-to-midi')}
              sx={{
                color: colors.text,
                fontWeight: 500,
                textTransform: 'none',
                px: 3,
                py: 1,
                borderRadius: 2,
                '&:hover': { bgcolor: colors.background, color: colors.accent }
              }}
            >
              악보 연주
            </Button>

            <Button
              onClick={() => handleNavigation('/library')}
              sx={{
                color: colors.text,
                fontWeight: 500,
                textTransform: 'none',
                px: 3,
                py: 1,
                borderRadius: 2,
                '&:hover': { bgcolor: colors.background, color: colors.accent }
              }}
            >
              라이브러리
            </Button>
          </Box>

          {/* 사용자 인증 버튼 */}
          <Box sx={{ display: { xs: 'none', md: 'flex' }, alignItems: 'center', gap: 2 }}>
            {isAuthed ? (
              <>
                <Typography sx={{ color: colors.textLight, fontWeight: 500 }}>
                  {auth.user.displayName || auth.user.email}
                </Typography>
                <Button
                  onClick={handleSignOut}
                  sx={{
                    color: '#041311',
                    bgcolor: colors.accent,
                    px: 3,
                    py: 1,
                    borderRadius: 2,
                    textTransform: 'none',
                    fontWeight: 600,
                    '&:hover': { bgcolor: '#26b8a4' }
                  }}
                >
                  로그아웃
                </Button>
              </>
            ) : (
              <Button
                onClick={() => handleNavigation('/auth')}
                sx={{
                  color: '#041311',
                  bgcolor: colors.accent,
                  px: 3,
                  py: 1,
                  borderRadius: 2,
                  textTransform: 'none',
                  fontWeight: 600,
                  '&:hover': { bgcolor: '#26b8a4' }
                }}
              >
                로그인
              </Button>
            )}
          </Box>

          {/* 모바일 메뉴 */}
          <Box sx={{ display: { xs: 'flex', md: 'none' }, alignItems: 'center', gap: 1 }}>
            <IconButton
              size="large"
              sx={{ color: colors.text, '&:hover': { bgcolor: colors.background, color: colors.accent } }}
              onClick={() => handleNavigation('/generate')} // 모바일 메뉴 클릭 시 단순 이동
            >
              <Menu />
            </IconButton>

            {isAuthed ? (
              <Button
                onClick={handleSignOut}
                size="small"
                sx={{
                  color: '#041311',
                  bgcolor: colors.accent,
                  px: 2,
                  borderRadius: 2,
                  textTransform: 'none',
                  fontWeight: 600,
                  '&:hover': { bgcolor: '#26b8a4' }
                }}
              >
                로그아웃
              </Button>
            ) : (
              <Button
                onClick={() => handleNavigation('/auth')}
                size="small"
                sx={{
                  color: '#041311',
                  bgcolor: colors.accent,
                  px: 2,
                  borderRadius: 2,
                  textTransform: 'none',
                  fontWeight: 600,
                  '&:hover': { bgcolor: '#26b8a4' }
                }}
              >
                로그인
              </Button>
            )}
          </Box>
        </Toolbar>
      </Container>
    </AppBar>
  );
};

export default Navbar;
</file>

<file path="src/context/MusicContext.js">
import React, { createContext, useContext, useReducer, useCallback, useEffect } from 'react';
import {
  onAuthStateChanged,
  createUserWithEmailAndPassword,
  signInWithEmailAndPassword,
  signOut as firebaseSignOut,
  updateProfile,
} from 'firebase/auth';
import { subscribeToUserLibrary } from '../services/libraryApi';

import { auth as firebaseAuth } from '../lib/firebase';

// 초기 상태 정의
const initialState = {
  // 음악 생성 관련 상태
  generation: {
    selectedGenres: [],
    selectedMoods: [],
    description: '',
    duration: 30, // 초 단위 (기본 2분)
    isGenerating: false,
    generationProgress: 0,
  },
  
  // 음악 변환 관련 상태
  conversion: {
    uploadedFile: null,
    targetGenre: '',
    conversionIntensity: 3, // 1-5 스케일
    isConverting: false,
    conversionProgress: 0,
  },
  
  // 결과 관련 상태
  result: {
    generatedMusic: null,
    convertedMusic: null,
    isPlaying: false,
    currentTime: 0,
    duration: 0,
  },
  
  // 인증 상태
  auth: {
    user: null,
    status: 'idle', // idle | loading | authenticated | unauthenticated | error
    error: null,
  },
  
  // 라이브러리 관련 상태
  library: {
    musicList: [],
    selectedMusic: null,
    sortBy: 'date', // 'date', 'genre', 'favorites'
    filterBy: 'all', // 'all', 'generated', 'converted'
    loading: false,
    error: null,
  },
  
  // UI 상태
  ui: {
    currentPage: 'generate',
    notifications: [],
    loading: false,
    error: null,
  }
};

// 액션 타입 정의
const actionTypes = {
  // 음악 생성 액션
  SET_SELECTED_GENRES: 'SET_SELECTED_GENRES',
  SET_SELECTED_MOODS: 'SET_SELECTED_MOODS',
  SET_DESCRIPTION: 'SET_DESCRIPTION',
  SET_DURATION: 'SET_DURATION',
  START_GENERATION: 'START_GENERATION',
  UPDATE_GENERATION_PROGRESS: 'UPDATE_GENERATION_PROGRESS',
  COMPLETE_GENERATION: 'COMPLETE_GENERATION',
  
  // 음악 변환 액션
  SET_UPLOADED_FILE: 'SET_UPLOADED_FILE',
  SET_TARGET_GENRE: 'SET_TARGET_GENRE',
  SET_CONVERSION_INTENSITY: 'SET_CONVERSION_INTENSITY',
  START_CONVERSION: 'START_CONVERSION',
  UPDATE_CONVERSION_PROGRESS: 'UPDATE_CONVERSION_PROGRESS',
  COMPLETE_CONVERSION: 'COMPLETE_CONVERSION',
  
  // 재생 관련 액션
  SET_PLAYING: 'SET_PLAYING',
  UPDATE_CURRENT_TIME: 'UPDATE_CURRENT_TIME',
  SET_RESULT_MUSIC: 'SET_RESULT_MUSIC',
  SET_RESULT: 'SET_RESULT',
  
  // 라이브러리 액션
  ADD_TO_LIBRARY: 'ADD_TO_LIBRARY',
  REMOVE_FROM_LIBRARY: 'REMOVE_FROM_LIBRARY',
  SET_LIBRARY_ITEMS: 'SET_LIBRARY_ITEMS',
  SET_LIBRARY_LOADING: 'SET_LIBRARY_LOADING',
  SET_LIBRARY_ERROR: 'SET_LIBRARY_ERROR',
  CLEAR_LIBRARY: 'CLEAR_LIBRARY',
  UPDATE_LIBRARY_SORT: 'UPDATE_LIBRARY_SORT',
  UPDATE_LIBRARY_FILTER: 'UPDATE_LIBRARY_FILTER',
  
  // UI 액션
  SET_CURRENT_PAGE: 'SET_CURRENT_PAGE',
  ADD_NOTIFICATION: 'ADD_NOTIFICATION',
  REMOVE_NOTIFICATION: 'REMOVE_NOTIFICATION',
  SET_LOADING: 'SET_LOADING',
  SET_ERROR: 'SET_ERROR',
  CLEAR_ERROR: 'CLEAR_ERROR',

  // 인증 액션
  AUTH_SET_STATUS: 'AUTH_SET_STATUS',
  AUTH_STATE_CHANGE: 'AUTH_STATE_CHANGE',
  AUTH_SET_ERROR: 'AUTH_SET_ERROR',
};

// 리듀서 함수
function musicReducer(state, action) {
  switch (action.type) {
    // 음악 생성 관련
    case actionTypes.SET_SELECTED_GENRES:
      return {
        ...state,
        generation: {
          ...state.generation,
          selectedGenres: action.payload
        }
      };
    
    case actionTypes.SET_SELECTED_MOODS:
      return {
        ...state,
        generation: {
          ...state.generation,
          selectedMoods: action.payload
        }
      };
    
    case actionTypes.SET_DESCRIPTION:
      return {
        ...state,
        generation: {
          ...state.generation,
          description: action.payload
        }
      };
    
    case actionTypes.SET_DURATION:
      return {
        ...state,
        generation: {
          ...state.generation,
          duration: action.payload
        }
      };
    
    case actionTypes.START_GENERATION:
      return {
        ...state,
        generation: {
          ...state.generation,
          isGenerating: true,
          generationProgress: 0
        },
        ui: {
          ...state.ui,
          loading: true,
          error: null
        }
      };
    
    case actionTypes.UPDATE_GENERATION_PROGRESS:
      return {
        ...state,
        generation: {
          ...state.generation,
          generationProgress: action.payload
        }
      };
    
    case actionTypes.COMPLETE_GENERATION:
      return {
        ...state,
        generation: {
          ...state.generation,
          isGenerating: false,
          generationProgress: 100
        },
        result: {
          ...state.result,
          generatedMusic: action.payload
        },
        ui: {
          ...state.ui,
          loading: false,
          currentPage: 'result'
        }
      };
    
    // 음악 변환 관련
    case actionTypes.SET_UPLOADED_FILE:
      return {
        ...state,
        conversion: {
          ...state.conversion,
          uploadedFile: action.payload
        }
      };
    
    case actionTypes.SET_TARGET_GENRE:
      return {
        ...state,
        conversion: {
          ...state.conversion,
          targetGenre: action.payload
        }
      };
    
    case actionTypes.SET_CONVERSION_INTENSITY:
      return {
        ...state,
        conversion: {
          ...state.conversion,
          conversionIntensity: action.payload
        }
      };
    
    case actionTypes.START_CONVERSION:
      return {
        ...state,
        conversion: {
          ...state.conversion,
          isConverting: true,
          conversionProgress: 0
        },
        ui: {
          ...state.ui,
          loading: true,
          error: null
        }
      };
    
    case actionTypes.COMPLETE_CONVERSION:
      return {
        ...state,
        conversion: {
          ...state.conversion,
          isConverting: false,
          conversionProgress: 100
        },
        result: {
          ...state.result,
          convertedMusic: action.payload
        },
        ui: {
          ...state.ui,
          loading: false,
          currentPage: 'result'
        }
      };
    
    // 재생 관련
    case actionTypes.SET_PLAYING:
      return {
        ...state,
        result: {
          ...state.result,
          isPlaying: action.payload
        }
      };
    
    case actionTypes.UPDATE_CURRENT_TIME:
      return {
        ...state,
        result: {
          ...state.result,
          currentTime: action.payload
        }
      };

      case actionTypes.SET_RESULT:
      return {
        ...state,
        result: {
          ...state.result,
          ...action.payload
        }
      };
    
    // 라이브러리 관련
    case actionTypes.ADD_TO_LIBRARY:
      return {
        ...state,
        library: {
          ...state.library,
          musicList: [...state.library.musicList, action.payload]
        }
      };

    case actionTypes.SET_LIBRARY_ITEMS:
      return {
        ...state,
        library: {
          ...state.library,
          musicList: action.payload,
          loading: false,
          error: null,
        },
      };

    case actionTypes.SET_LIBRARY_LOADING:
      return {
        ...state,
        library: {
          ...state.library,
          loading: action.payload,
        },
      };

    case actionTypes.SET_LIBRARY_ERROR:
      return {
        ...state,
        library: {
          ...state.library,
          error: action.payload,
          loading: false,
        },
      };

    case actionTypes.CLEAR_LIBRARY:
      return {
        ...state,
        library: {
          ...state.library,
          musicList: [],
          loading: false,
          error: null,
        },
      };

    // UI 관련
    case actionTypes.SET_CURRENT_PAGE:
      return {
        ...state,
        ui: {
          ...state.ui,
          currentPage: action.payload
        }
      };
    
    case actionTypes.ADD_NOTIFICATION:
      return {
        ...state,
        ui: {
          ...state.ui,
          notifications: [...state.ui.notifications, action.payload]
        }
      };
    
    case actionTypes.REMOVE_NOTIFICATION:
      return {
        ...state,
        ui: {
          ...state.ui,
          notifications: state.ui.notifications.filter(
            notification => notification.id !== action.payload
          )
        }
      };
    
    case actionTypes.SET_ERROR:
      return {
        ...state,
        ui: {
          ...state.ui,
          error: action.payload,
          loading: false
        }
      };
    
    case actionTypes.CLEAR_ERROR:
      return {
        ...state,
        ui: {
          ...state.ui,
          error: null
        }
      };

    // 인증 관련
    case actionTypes.AUTH_SET_STATUS:
      return {
        ...state,
        auth: {
          ...state.auth,
          status: action.payload,
        },
      };

    case actionTypes.AUTH_STATE_CHANGE:
      return {
        ...state,
        auth: {
          ...state.auth,
          user: action.payload,
          status: action.payload ? 'authenticated' : 'unauthenticated',
          error: null,
        },
      };

    case actionTypes.AUTH_SET_ERROR:
      return {
        ...state,
        auth: {
          ...state.auth,
          error: action.payload,
        },
      };

    default:
      return state;
  }
}

// Context 생성
const MusicContext = createContext();

// Context Provider 컴포넌트
export function MusicContextProvider({ children }) {
  const [state, dispatch] = useReducer(musicReducer, initialState);
  const pushNotification = useCallback((notification) => {
    const notificationWithId = {
      ...notification,
      id: Date.now() + Math.random(),
    };
    dispatch({ type: actionTypes.ADD_NOTIFICATION, payload: notificationWithId });
  }, [dispatch]);
  
  // 액션 크리에이터들을 useCallback으로 메모이제이션
  const actions = {
    // 음악 생성 관련 액션들
    setSelectedGenres: useCallback((genres) => {
      dispatch({ type: actionTypes.SET_SELECTED_GENRES, payload: genres });
    }, []),
    
    setSelectedMoods: useCallback((moods) => {
      dispatch({ type: actionTypes.SET_SELECTED_MOODS, payload: moods });
    }, []),
    
    setDescription: useCallback((description) => {
      dispatch({ type: actionTypes.SET_DESCRIPTION, payload: description });
    }, []),
    
    setDuration: useCallback((duration) => {
      dispatch({ type: actionTypes.SET_DURATION, payload: duration });
    }, []),
    
    startGeneration: useCallback(() => {
      dispatch({ type: actionTypes.START_GENERATION });
    }, []),
    
    updateGenerationProgress: useCallback((progress) => {
      dispatch({ type: actionTypes.UPDATE_GENERATION_PROGRESS, payload: progress });
    }, []),
    
    completeGeneration: useCallback((musicData) => {
      dispatch({ type: actionTypes.COMPLETE_GENERATION, payload: musicData });
    }, []),
    
    // 음악 변환 관련 액션들
    setUploadedFile: useCallback((file) => {
      dispatch({ type: actionTypes.SET_UPLOADED_FILE, payload: file });
    }, []),
    
    setTargetGenre: useCallback((genre) => {
      dispatch({ type: actionTypes.SET_TARGET_GENRE, payload: genre });
    }, []),
    
    setConversionIntensity: useCallback((intensity) => {
      dispatch({ type: actionTypes.SET_CONVERSION_INTENSITY, payload: intensity });
    }, []),
    
    startConversion: useCallback(() => {
      dispatch({ type: actionTypes.START_CONVERSION });
    }, []),
    
    completeConversion: useCallback((musicData) => {
      dispatch({ type: actionTypes.COMPLETE_CONVERSION, payload: musicData });
    }, []),
    
    // 재생 관련 액션들
    setPlaying: useCallback((isPlaying) => {
      dispatch({ type: actionTypes.SET_PLAYING, payload: isPlaying });
    }, []),
    
    updateCurrentTime: useCallback((time) => {
      dispatch({ type: actionTypes.UPDATE_CURRENT_TIME, payload: time });
    }, []),
    
    setResult: useCallback((resultData) => {
      console.log('MusicContext setResult 호출됨:', resultData);
      dispatch({ type: actionTypes.SET_RESULT, payload: resultData });
    }, []),

    // 라이브러리 관련 액션들
    addToLibrary: useCallback((musicData) => {
      dispatch({ type: actionTypes.ADD_TO_LIBRARY, payload: musicData });
    }, []),

    setLibraryItems: useCallback((items) => {
      dispatch({ type: actionTypes.SET_LIBRARY_ITEMS, payload: items });
    }, [dispatch]),

    setLibraryLoading: useCallback((flag) => {
      dispatch({ type: actionTypes.SET_LIBRARY_LOADING, payload: flag });
    }, [dispatch]),

    setLibraryError: useCallback((error) => {
      dispatch({ type: actionTypes.SET_LIBRARY_ERROR, payload: error });
    }, [dispatch]),

    // 인증 관련 액션들
    setAuthStatus: useCallback((status) => {
      dispatch({ type: actionTypes.AUTH_SET_STATUS, payload: status });
    }, []),

    setAuthError: useCallback((error) => {
      dispatch({ type: actionTypes.AUTH_SET_ERROR, payload: error });
    }, []),

    signUpWithEmail: useCallback(async ({ email, password, displayName }) => {
      dispatch({ type: actionTypes.AUTH_SET_STATUS, payload: 'loading' });
      try {
        const cred = await createUserWithEmailAndPassword(firebaseAuth, email, password);
        if (displayName) {
          await updateProfile(cred.user, { displayName });
        }
        pushNotification({ type: 'success', message: '회원가입이 완료되었어요!' });
        return cred.user;
      } catch (error) {
        const message = error?.message || '회원가입에 실패했어요.';
        dispatch({ type: actionTypes.AUTH_SET_ERROR, payload: message });
        dispatch({ type: actionTypes.AUTH_SET_STATUS, payload: 'unauthenticated' });
        pushNotification({ type: 'error', message });
        throw error;
      }
    }, [pushNotification]),

    signInWithEmail: useCallback(async ({ email, password }) => {
      dispatch({ type: actionTypes.AUTH_SET_STATUS, payload: 'loading' });
      try {
        const cred = await signInWithEmailAndPassword(firebaseAuth, email, password);
        pushNotification({ type: 'success', message: '환영합니다! 로그인에 성공했어요.' });
        return cred.user;
      } catch (error) {
        const message = error?.message || '로그인에 실패했어요.';
        dispatch({ type: actionTypes.AUTH_SET_ERROR, payload: message });
        dispatch({ type: actionTypes.AUTH_SET_STATUS, payload: 'unauthenticated' });
        pushNotification({ type: 'error', message });
        throw error;
      }
    }, [pushNotification]),

    signOut: useCallback(async () => {
      dispatch({ type: actionTypes.AUTH_SET_STATUS, payload: 'loading' });
      try {
        await firebaseSignOut(firebaseAuth);
        pushNotification({ type: 'info', message: '로그아웃되었어요.' });
      } catch (error) {
        const message = error?.message || '로그아웃 중 문제가 발생했어요.';
        dispatch({ type: actionTypes.AUTH_SET_ERROR, payload: message });
        dispatch({ type: actionTypes.AUTH_SET_STATUS, payload: 'error' });
        pushNotification({ type: 'error', message });
        throw error;
      }
    }, [pushNotification]),

    // UI 관련 액션들
    setCurrentPage: useCallback((page) => {
      dispatch({ type: actionTypes.SET_CURRENT_PAGE, payload: page });
    }, []),
    
    addNotification: useCallback((notification) => {
      pushNotification(notification);
    }, [pushNotification]),
    
    removeNotification: useCallback((id) => {
      dispatch({ type: actionTypes.REMOVE_NOTIFICATION, payload: id });
    }, []),
    
    setError: useCallback((error) => {
      dispatch({ type: actionTypes.SET_ERROR, payload: error });
    }, []),
    
    clearError: useCallback(() => {
      dispatch({ type: actionTypes.CLEAR_ERROR });
    }, []),
  };
  
  const value = {
    state,
    actions,
    dispatch
  };

  useEffect(() => {
    // 초기 로딩 상태를 표시하고 Firebase Auth 상태 변화를 구독
    dispatch({ type: actionTypes.AUTH_SET_STATUS, payload: 'loading' });
    const unsubscribe = onAuthStateChanged(
      firebaseAuth,
      (firebaseUser) => {
        if (firebaseUser) {
          const { uid, displayName, email, photoURL } = firebaseUser;
          dispatch({
            type: actionTypes.AUTH_STATE_CHANGE,
            payload: { uid, displayName, email, photoURL },
          });
        } else {
          dispatch({ type: actionTypes.AUTH_STATE_CHANGE, payload: null });
        }
      },
      (error) => {
        dispatch({
          type: actionTypes.AUTH_SET_ERROR,
          payload: error?.message || 'Authentication error',
        });
        dispatch({ type: actionTypes.AUTH_SET_STATUS, payload: 'error' });
      }
    );

    return () => unsubscribe();
  }, [dispatch]);

  useEffect(() => {
    let unsubscribeLibrary = null;
    const userId = state.auth.user?.uid;

    if (userId) {
      dispatch({ type: actionTypes.SET_LIBRARY_LOADING, payload: true });
      unsubscribeLibrary = subscribeToUserLibrary(userId, {
        onUpdate: (items) => {
          dispatch({ type: actionTypes.SET_LIBRARY_ITEMS, payload: items });
        },
        onError: (error) => {
          dispatch({
            type: actionTypes.SET_LIBRARY_ERROR,
            payload: error?.message || '라이브러리를 불러오지 못했어요.',
          });
          pushNotification({ type: 'error', message: '라이브러리 데이터를 불러오지 못했어요.' });
        },
      });
    } else {
      dispatch({ type: actionTypes.CLEAR_LIBRARY });
    }

    return () => {
      unsubscribeLibrary?.();
    };
  }, [state.auth.user?.uid, pushNotification, dispatch]);

  return (
    <MusicContext.Provider value={value}>
      {children}
    </MusicContext.Provider>
  );
}

// 커스텀 훅
export function useMusicContext() {
  const context = useContext(MusicContext);
  if (!context) {
    throw new Error('useMusicContext must be used within a MusicContextProvider');
  }
  return context;
}

export { actionTypes };
</file>

<file path="src/hooks/useBeatMakerEngine.js">
// src/hooks/useBeatMakerEngine.js

import { useEffect, useRef, useMemo } from "react";
import { useBeatPad } from "../state/beatPadStore";
import * as Tone from "tone";
import { createKit } from "../components/beat/SampleKit";
import { clonePattern, TRACKS, PATTERN_STEPS } from "../components/beat/presets";
import { loadDrumsVAE, encodeCorners, decodeAtPosition } from "../lib/drumsVAE";
import { samplePathByDistance } from "./usePathMode";
import { useCellGrid } from "./useCellGrid";
import { audioBufferToWav } from "../utils/audioExport";
import { useMusicContext } from "../context/MusicContext";

const blendWeights = (x, y) => ({
  A: (1 - x) * (1 - y),
  B: x * (1 - y),
  C: (1 - x) * y,
  D: x * y,
});

function simpleBlend(corners, x, y, threshold = 0.5) {
  if (!corners) return null;
  const w = blendWeights(x, y);
  const result = {};
  TRACKS.forEach((track) => {
    result[track] = Array.from({ length: PATTERN_STEPS }, (_, idx) => {
      const val =
        (corners.A?.[track]?.[idx] ? 1 : 0) * w.A +
        (corners.B?.[track]?.[idx] ? 1 : 0) * w.B +
        (corners.C?.[track]?.[idx] ? 1 : 0) * w.C +
        (corners.D?.[track]?.[idx] ? 1 : 0) * w.D;
      return val >= threshold;
    });
  });
  return result;
}

const TRACK_TO_PLAYER_KEY_MAP = {
  kick: "kick",
  snare: "snare",
  hatClose: "hatC",
  hatOpen: "hatO",
  tomLow: "tomL",
  tomMid: "tomM",
  tomHigh: "tomH",
  crash: "crash",
  ride: "ride",
};

export function useBeatMakerEngine() {
  const { state, dispatch } = useBeatPad();
  const { actions: globalActions } = useMusicContext();
  const { toCell, centerOf } = useCellGrid(state.grid.cols, state.grid.rows);
  const kitRef = useRef(null);
  const partRef = useRef(null);
  const stateRef = useRef(state);
  const pathPatternsRef = useRef([]);
  const pathPositionsRef = useRef([]);
  const pathVersionRef = useRef(0);
  const lastManualPatternRef = useRef(state.pattern);
  const wasPathPlayingRef = useRef(false);
  const blendRequestRef = useRef(0);
  const lastVaeCall = useRef(0);
  const VAE_DEBOUNCE_DELAY = 100;

  // --- VAE 모델 로딩 ---
  useEffect(() => {
    loadDrumsVAE().then(() => console.log("MusicVAE model loaded.")).catch((err) => {
      console.error("Failed to load MusicVAE model", err);
    });
  }, []);

  // 1. 컴포넌트가 처음 마운트될 때 Tone.js와 드럼 샘플을 초기화합니다.
  useEffect(() => {
    const initAudio = async () => {
      await Tone.start();
      kitRef.current = await createKit();
      Tone.Transport.bpm.value = state.bpm;
    };
    initAudio();

    // 컴포넌트가 언마운트될 때 오디오 리소스를 정리합니다.
    return () => {
      Tone.Transport.stop();
      Tone.Transport.cancel();
      kitRef.current?.players?.dispose();
      kitRef.current?.gain?.dispose();
    };
  }, []); // 빈 배열: 최초 1회만 실행

  useEffect(() => {
    stateRef.current = state;
  }, [state]);

  useEffect(() => {
    const nowPathPlaying = state.drawMode === "PATH" && state.isPlaying;
    if (nowPathPlaying && !wasPathPlayingRef.current) {
      lastManualPatternRef.current = state.pattern;
    }
    if (!nowPathPlaying && wasPathPlayingRef.current) {
      if (lastManualPatternRef.current) {
        dispatch({ type: "SET_PATTERN", payload: lastManualPatternRef.current });
      }
    }
    wasPathPlayingRef.current = nowPathPlaying;
  }, [state.drawMode, state.isPlaying, state.pattern, dispatch]);

  useEffect(() => {
    if (state.drawMode !== "PATH") {
      lastManualPatternRef.current = state.pattern;
    }
  }, [state.pattern, state.drawMode]);

  useEffect(() => {
    if (state.mode === "EDIT" && state.selectedCorner) {
      const cornerPattern = state.cornerPatterns[state.selectedCorner];
      if (cornerPattern) {
        dispatch({ type: "SET_PATTERN", payload: clonePattern(cornerPattern) });
      }
    }
  }, [state.mode, state.selectedCorner, state.cornerPatterns, dispatch]);

  // --- 코너 패턴이 변경되면 자동으로 인코딩 수행 ---
  useEffect(() => {
    let cancelled = false;
    (async () => {
      if (!state.cornerPatterns) {
        dispatch({ type: "SET_CORNER_ENCODINGS", payload: null });
        return;
      }
      const valid = Object.values(state.cornerPatterns).every(Boolean);
      if (!valid) return;
      try {
        const encodings = await encodeCorners(state.cornerPatterns);
        if (!cancelled) {
          dispatch({ type: "SET_CORNER_ENCODINGS", payload: encodings });
        }
      } catch (e) {
        console.error("Failed to encode corner patterns:", e);
      }
    })();
    return () => {
      cancelled = true;
    };
  }, [state.cornerPatterns, dispatch]);

  // 2. 중앙 상태의 bpm 값이 변경될 때마다 Tone.Transport에 반영합니다.
  useEffect(() => {
    if (Tone.Transport) {
      Tone.Transport.bpm.value = state.bpm;
    }
  }, [state.bpm]);

  const fillPartWithPattern = () => {
    const part = partRef.current;
    if (!part) return;

    part.clear();
    const totalSteps = PATTERN_STEPS;
    const stepDurationSeconds = Tone.Time("1m").toSeconds() / totalSteps;

    for (let step = 0; step < totalSteps; step++) {
      const timeSeconds = step * stepDurationSeconds;
      part.add(timeSeconds, { step, index: step, totalSteps });
    }
  };

  // 3. 재생 로직을 Tone.Part 기반으로 구현합니다.
  useEffect(() => {
    if (state.isPlaying) {
      if (!partRef.current) {
        const part = new Tone.Part(async (time, note) => {
          const currentState = stateRef.current;
          let patternToPlay = currentState.pattern;
          const totalSteps = note.totalSteps || PATTERN_STEPS;
          const stepIndex = note.index % totalSteps;

          if (currentState.drawMode === "PATH" && currentState.path.length > 1) {
            const sampledPattern = pathPatternsRef.current[stepIndex];
            const sampledPosition = pathPositionsRef.current[stepIndex];
            if (sampledPattern) {
              patternToPlay = sampledPattern;
            }
            if (sampledPosition) {
              Tone.Draw.schedule(() => {
                dispatch({ type: "SET_PUCK_POSITION", payload: { position: sampledPosition, index: stepIndex } });
              }, time);
            }
          }

          Object.entries(patternToPlay || {}).forEach(([trackName, steps]) => {
            if (steps?.[note.step]) {
              const playerKey = TRACK_TO_PLAYER_KEY_MAP[trackName];
              if (playerKey) {
                kitRef.current?.players.player(playerKey).start(time);
              }
            }
          });

          Tone.Draw.schedule(() => {
            dispatch({ type: "SET_CURRENT_STEP", payload: note.step });
            if (currentState.drawMode === "PATH" && patternToPlay) {
              dispatch({ type: "SET_PATTERN", payload: patternToPlay });
            }
          }, time);
        }, []).start(0);

        part.loop = true;
        partRef.current = part;
      }

      partRef.current.loopEnd = "1m";
      fillPartWithPattern();
      if (Tone.Transport.state !== "started") {
        Tone.Transport.start("+0.1");
      }
    } else {
      Tone.Transport.stop();
    }

    return () => {
      Tone.Transport.stop();
    };
  }, [state.isPlaying, dispatch]);

  useEffect(() => {
    if (state.isPlaying) {
      fillPartWithPattern();
    }
  }, [state.isPlaying]);

  useEffect(() => {
    if (!(state.path.length > 1 && state.cornerEncodings)) {
      pathPatternsRef.current = [];
      pathPositionsRef.current = [];
      return;
    }

    const version = ++pathVersionRef.current;
    const totalSteps = PATTERN_STEPS;
    const denominator = Math.max(1, totalSteps - 1);
    const positions = Array(totalSteps)
      .fill(null)
      .map((_, step) => {
        const progress = totalSteps === 1 ? 0 : step / denominator;
        return samplePathByDistance(state.path, progress);
      });
    pathPositionsRef.current = positions;

    (async () => {
      try {
        const decodePromises = positions.map((pos) =>
          decodeAtPosition(state.cornerEncodings, pos.x, pos.y).catch((error) => {
            console.error("Failed to decode path step", error);
            return null;
          })
        );
        const patterns = await Promise.all(decodePromises);
        if (pathVersionRef.current === version) {
          pathPatternsRef.current = patterns;
        }
      } catch (error) {
        console.error("Path decoding batch failed", error);
      }
    })();
  }, [state.path, state.cornerEncodings]);

  // 4. UI 컴포넌트에서 사용할 액션 함수들을 정의합니다.
  const actions = useMemo(
    () => ({
      setIsPlaying: (playing) => dispatch({ type: "SET_IS_PLAYING", payload: playing }),
      setBpm: (newBpm) => dispatch({ type: "SET_BPM", payload: newBpm }),
      setPattern: (newPattern) => dispatch({ type: "SET_PATTERN", payload: newPattern }),
      clearPattern: () => dispatch({ type: "SET_PATTERN", payload: clonePattern() }),
      handleBlend: async (x, y) => {
        const cell = toCell(x, y);
        dispatch({ type: "SET_PUCK_POSITION", payload: { position: { x, y }, index: cell.index } });

        if (!state.cornerEncodings) {
          const fallback = simpleBlend(state.cornerPatterns, x, y);
          if (fallback) {
            dispatch({ type: "SET_PATTERN", payload: fallback });
          } else {
            console.warn("Corner encodings not ready yet.");
          }
          return;
        }
        const requestId = ++blendRequestRef.current;
        try {
          const newPattern = await decodeAtPosition(state.cornerEncodings, x, y);
          if (blendRequestRef.current === requestId) {
            dispatch({ type: "SET_PATTERN", payload: newPattern });
          }
        } catch (e) {
          console.error("Failed to decode at position:", e);
        }
      },
      setCornerPreset: (corner, presetName) =>
        dispatch({ type: "SET_CORNER_PRESET", payload: { corner, presetName } }),
      setDrawMode: (mode) => dispatch({ type: "SET_DRAW_MODE", payload: mode }),
      setMode: (mode) => dispatch({ type: "SET_MODE", payload: mode }),
      selectCorner: (corner) => dispatch({ type: "SELECT_CORNER", payload: corner }),
      updateEditingPattern: (track, step) =>
        dispatch({ type: "UPDATE_EDITING_PATTERN", payload: { track, step } }),
      handleDoneEditing: async () => {
        dispatch({ type: "START_INTERPOLATION" });
        try {
          const encodings = await encodeCorners(state.cornerPatterns);
          const totalCells = state.grid.cols * state.grid.rows;
          const patterns = await Promise.all(
            Array.from({ length: totalCells }).map((_, idx) => {
              const row = Math.floor(idx / state.grid.cols);
              const col = idx % state.grid.cols;
              const coords = centerOf({ col, row });
              return decodeAtPosition(encodings, coords.x, coords.y);
            })
          );
          dispatch({ type: "FINISH_INTERPOLATION", payload: { encodings, patterns } });
        } catch (error) {
          console.error("Failed to interpolate:", error);
          dispatch({ type: "SET_MODE", payload: "INTERPOLATE" });
        }
      },
      handleExport: async () => {
        if (!kitRef.current) return;
        globalActions?.addNotification?.({ type: "info", message: "WAV 파일 렌더링 중..." });

        try {
          const totalDuration = Tone.Time("1m").toSeconds();
          const audioBuffer = await Tone.Offline(async ({ transport }) => {
            transport.bpm.value = state.bpm;
            const offlineKit = await createKit({ skipToneStart: true });
            const stepDuration = Tone.Time("16n").toSeconds();
            const totalSteps = PATTERN_STEPS;

            for (let step = 0; step < totalSteps; step++) {
              const eventTime = step * stepDuration;
              Object.entries(state.pattern).forEach(([trackName, steps]) => {
                if (steps[step % PATTERN_STEPS]) {
                  const playerKey = TRACK_TO_PLAYER_KEY_MAP[trackName];
                  if (playerKey) {
                    offlineKit.players.player(playerKey).start(eventTime);
                  }
                }
              });
            }

            transport.scheduleOnce(() => {
              offlineKit.players.dispose();
              offlineKit.gain?.dispose?.();
            }, totalDuration);
            transport.start(0);
          }, totalDuration);

          const blob = audioBufferToWav(audioBuffer);
          const url = URL.createObjectURL(blob);
          const anchor = document.createElement("a");
          anchor.href = url;
          anchor.download = `beat-${Date.now()}.wav`;
          anchor.click();
          URL.revokeObjectURL(url);
          globalActions?.addNotification?.({ type: "success", message: "WAV 파일이 다운로드되었습니다." });
        } catch (error) {
          console.error("Export failed:", error);
          globalActions?.addNotification?.({ type: "error", message: "파일 내보내기에 실패했습니다." });
        }
      },
    }),
    [centerOf, dispatch, globalActions, state.cornerEncodings, state.cornerPatterns, state.grid, state.pattern, toCell]
  );

  // 5. 훅의 최종 반환값
  return {
    state,
    actions,
  };
}
</file>

<file path="src/hooks/useCellGrid.js">
export function useCellGrid(cols, rows) {
  const clamp01 = (v) => Math.max(0, Math.min(1, v));

  // 화면 좌표(0~1)를 -> 셀 인덱스 정보로 바꾸기
  const toCell = (x01, y01) => {
    const c = Math.floor(clamp01(x01) * cols);
    const r = Math.floor(clamp01(y01) * rows);
    const col = Math.min(c, cols - 1);
    const row = Math.min(r, rows - 1);
    return { col, row, index: row * cols + col };
  };

  // 셀의 가운데점을 다시 0~1 좌표로
  const centerOf = ({ col, row }) => ({
    x: (col + 0.5) / cols,
    y: (row + 0.5) / rows,
  });

  return { toCell, centerOf };
}
</file>

<file path="src/hooks/useLerpTween.js">
import { useRef } from "react";

export default function useLerpTween() {
  const rafRef = useRef(null);

  const start = ({ duration = 600, onUpdate, onEnd }) => {
    stop();
    const t0 = performance.now();
    const step = (now) => {
      const t = Math.min(1, (now - t0) / duration);
      onUpdate?.(t);
      if (t < 1) rafRef.current = requestAnimationFrame(step);
      else onEnd?.();
    };
    rafRef.current = requestAnimationFrame(step);
  };

  const stop = () => {
    if (rafRef.current != null) cancelAnimationFrame(rafRef.current);
    rafRef.current = null;
  };

  return { start, stop };
}
</file>

<file path="src/hooks/usePathMode.js">
// src/hooks/usePathMode.js

const lerp = (a, b, t) => a + (b - a) * t;

/**
 * 경로와 진행률(t)을 받아, 실제 거리를 기준으로 보간된 좌표를 반환합니다.
 * @param {Array<{x: number, y: number}>} path - 좌표 점들의 배열
 * @param {number} t - 전체 경로에서의 진행률 (0.0 ~ 1.0)
 * @returns {{x: number, y: number}} 보간된 좌표
 */
export function samplePathByDistance(path, t) {
  if (!path || path.length === 0) return { x: 0.5, y: 0.5 };
  if (t <= 0) return path[0];
  if (t >= 1) return path[path.length - 1];
  if (path.length === 1) return path[0];

  const cumulativeLengths = [0];
  let totalLength = 0;
  for (let i = 1; i < path.length; i++) {
    const p1 = path[i - 1];
    const p2 = path[i];
    const dx = p2.x - p1.x;
    const dy = p2.y - p1.y;
    totalLength += Math.hypot(dx, dy);
    cumulativeLengths.push(totalLength);
  }

  if (totalLength === 0) return path[0];

  const targetLength = t * totalLength;

  let segmentIndex = 0;
  while (
    segmentIndex < cumulativeLengths.length - 1 &&
    cumulativeLengths[segmentIndex + 1] < targetLength
  ) {
    segmentIndex++;
  }

  const lengthBeforeSegment = cumulativeLengths[segmentIndex];
  const segmentLength = cumulativeLengths[segmentIndex + 1] - lengthBeforeSegment;
  const segmentProgress =
    segmentLength === 0 ? 0 : (targetLength - lengthBeforeSegment) / segmentLength;

  const p1 = path[segmentIndex];
  const p2 = path[segmentIndex + 1];

  return {
    x: lerp(p1.x, p2.x, segmentProgress),
    y: lerp(p1.y, p2.y, segmentProgress),
  };
}
</file>

<file path="src/index.css">
body {
  margin: 0;
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
    'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',
    sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

code {
  font-family: source-code-pro, Menlo, Monaco, Consolas, 'Courier New',
    monospace;
}
</file>

<file path="src/index.js">
import './polyfills'; 
import React from 'react';
import ReactDOM from 'react-dom/client';
import './index.css';
import App from './App';
import reportWebVitals from './reportWebVitals';

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);

// If you want to start measuring performance in your app, pass a function
// to log results (for example: reportWebVitals(console.log))
// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals
reportWebVitals();
</file>

<file path="src/lib/audioUtils.js">
// Utility to convert an AudioBuffer to a WAV ArrayBuffer (16-bit PCM by default)
export function audioBufferToWav(buffer, { float32 = false } = {}) {
  const numChannels = buffer.numberOfChannels;
  const sampleRate = buffer.sampleRate;
  const format = float32 ? 3 : 1;
  const bitDepth = float32 ? 32 : 16;

  const bytesPerSample = bitDepth / 8;
  const blockAlign = numChannels * bytesPerSample;
  const dataLength = buffer.length * blockAlign;
  const bufferLength = 44 + dataLength;

  const arrayBuffer = new ArrayBuffer(bufferLength);
  const view = new DataView(arrayBuffer);

  writeString(view, 0, 'RIFF');
  view.setUint32(4, 36 + dataLength, true);
  writeString(view, 8, 'WAVE');
  writeString(view, 12, 'fmt ');
  view.setUint32(16, 16, true); // PCM chunk size
  view.setUint16(20, format, true);
  view.setUint16(22, numChannels, true);
  view.setUint32(24, sampleRate, true);
  view.setUint32(28, sampleRate * blockAlign, true);
  view.setUint16(32, blockAlign, true);
  view.setUint16(34, bitDepth, true);
  writeString(view, 36, 'data');
  view.setUint32(40, dataLength, true);

  // Write interleaved PCM samples
  let offset = 44;
  const channelData = [];
  for (let channel = 0; channel < numChannels; channel += 1) {
    channelData.push(buffer.getChannelData(channel));
  }

  const length = buffer.length;
  if (float32) {
    for (let i = 0; i < length; i += 1) {
      for (let channel = 0; channel < numChannels; channel += 1) {
        view.setFloat32(offset, channelData[channel][i], true);
        offset += 4;
      }
    }
  } else {
    for (let i = 0; i < length; i += 1) {
      for (let channel = 0; channel < numChannels; channel += 1) {
        const sample = Math.max(-1, Math.min(1, channelData[channel][i]));
        view.setInt16(offset, sample < 0 ? sample * 0x8000 : sample * 0x7FFF, true);
        offset += 2;
      }
    }
  }

  return arrayBuffer;
}

function writeString(view, offset, string) {
  for (let i = 0; i < string.length; i += 1) {
    view.setUint8(offset + i, string.charCodeAt(i));
  }
}
</file>

<file path="src/lib/beatblender/cellCache.js">
const store = new Map(); // key: `${version}:${index}` -> pattern

export const cellCache = {
  get(version, index) {
    return store.get(`${version}:${index}`) || null;
  },
  set(version, index, pattern) {
    store.set(`${version}:${index}`, pattern);
  },
  clearByVersion(version) {
    // 선택적: 지금은 굳이 안 써도 됨
    for (const k of store.keys()) {
      if (k.startsWith(version + ":")) {
        store.delete(k);
      }
    }
  },
};
</file>

<file path="src/lib/beatblender/color.js">
// Copyright 2018 Google LLC
// Licensed under the Apache License, Version 2.0

const clamp01 = (v) => Math.max(0, Math.min(1, v));
const lerp = (a, b, t) => a + (b - a) * t;
const lerpArray = (a, b, t) => {
  const n = Math.min(a.length, b.length);
  const out = new Array(n);
  for (let i = 0; i < n; i++) out[i] = lerp(a[i], b[i], t);
  return out;
};
const times = (n, fn) => Array.from({ length: n }, (_, i) => fn(i, n));

export const generate4PointGradient = (tl, tr, bl, br, columns, rows) => {
  return times(columns, (x, columns) => {
    const cp = columns === 1 ? 0 : x / (columns - 1);
    const topColor = lerpArray(tl, tr, cp);
    const bottomColor = lerpArray(bl, br, cp);
    return times(rows, (y, rows) => {
      const rp = rows === 1 ? 0 : y / (rows - 1);
      return lerpArray(topColor, bottomColor, rp);
    });
  });
};

export const generate4PointGradientAt = (
  tl, tr, bl, br, percentX, percentY, result = []
) => {
  const px = clamp01(percentX ?? 0);
  const py = clamp01(percentY ?? 0);
  const top = lerpArray(tl, tr, px);
  const bot = lerpArray(bl, br, px);
  const out = lerpArray(top, bot, py);
  result.length = 0;
  for (let i = 0; i < out.length; i++) result[i] = out[i];
  return result;
};

export const toCSSString = (arr) => {
  const [r = 0, g = 0, b = 0, a = 1] = arr;
  return `rgba(${Math.round(r)}, ${Math.round(g)}, ${Math.round(b)}, ${a})`;
};
</file>

<file path="src/lib/beatblender/coords.js">
export const clamp01 = (v) => Math.max(0, Math.min(1, v));

export const norm01 = (v, min = 0, max = 1) => {
  return clamp01((v - min) / (max - min));
};
</file>

<file path="src/lib/beatblender/previewRender.js">
// 셀 안에 흐릿한 미니 드럼 패턴을 그리는 도화지 유틸.
// 지금은 그냥 존재만 하게 심플 버전.

export function drawMiniPattern(ctx, x, y, w, h, pattern, opts = {}) {
  if (!pattern) return;
  const steps = 16;
  const tracks = opts.tracks ?? 9;
  const alpha = opts.alpha ?? 0.25;

  const cw = w / steps;
  const ch = h / tracks;

  ctx.save();
  ctx.globalAlpha = alpha;

  // pattern[track][step]이 1이면 박스 찍는다는 가정
  for (let tr = 0; tr < tracks; tr++) {
    for (let s = 0; s < steps; s++) {
      const on =
        pattern?.[tr]?.[s] === 1 ||
        pattern?.[tr]?.[s] === true;
      if (!on) continue;
      ctx.fillRect(
        x + s * cw + 1,
        y + tr * ch + 1,
        Math.max(1, cw - 2),
        Math.max(1, ch - 2)
      );
    }
  }

  ctx.restore();
}
</file>

<file path="src/lib/drumsVAE.js">
// src/lib/drumsVAE.js

import * as mm from '@magenta/music';
import { PATTERN_STEPS, TRACKS } from '../components/beat/presets';

const CKPT = 'https://storage.googleapis.com/download.magenta.tensorflow.org/tfjs_checkpoints/music_vae/drums_2bar_hikl_small';

let _vae = null;

export async function loadDrumsVAE() {
  if (_vae) return _vae;
  const vae = new mm.MusicVAE(CKPT);
  await vae.initialize();
  _vae = vae;
  return _vae;
}

const DRUM_PITCH_MAP = {
  kick: 36, snare: 38, hatClose: 42, hatOpen: 46,
  tomLow: 45, tomMid: 47, tomHigh: 50, crash: 49, ride: 51,
};
const PITCH_TO_TRACK_MAP = new Map(Object.entries(DRUM_PITCH_MAP).map(([k, v]) => [v, k]));

function patternToQuantizedNS(pattern) {
  const notes = [];
  TRACKS.forEach((trackName) => {
    if (pattern[trackName]) {
      pattern[trackName].forEach((active, step) => {
        if (active) {
          notes.push({
            pitch: DRUM_PITCH_MAP[trackName],
            quantizedStartStep: step,
            quantizedEndStep: step + 1,
          });
        }
      });
    }
  });
  return {
    notes,
    quantizationInfo: { stepsPerQuarter: 4 },
    totalQuantizedSteps: PATTERN_STEPS,
  };
}

function nsToPattern(ns) {
  const pattern = {};
  TRACKS.forEach(track => { pattern[track] = Array(PATTERN_STEPS).fill(false); });
  ns.notes.forEach(note => {
    const trackName = PITCH_TO_TRACK_MAP.get(note.pitch);
    if (trackName) {
      const step = Math.max(0, Math.min(PATTERN_STEPS - 1, Math.floor(note.quantizedStartStep)));
      pattern[trackName][step] = true;
    }
  });
  return pattern;
}

export async function encodeCorners(corners) {
  const vae = await loadDrumsVAE();
  const seqs = [corners.A, corners.B, corners.C, corners.D].map(patternToQuantizedNS);
  const z = await vae.encode(seqs);
  const zArr = await z.array();
  z.dispose();
  return zArr;
}

export async function decodeAtPosition(encodedLatents, x, y, opts = {}) {
  const vae = await loadDrumsVAE();
  const [zA, zB, zC, zD] = encodedLatents;
  const wA = (1 - x) * (1 - y);
  const wB = x * (1 - y);
  const wC = (1 - x) * y;
  const wD = x * y;

  const zDim = zA.length;
  const avg = new Array(zDim).fill(0);
  for (let i = 0; i < zDim; i++) {
    avg[i] = zA[i] * wA + zB[i] * wB + zC[i] * wC + zD[i] * wD;
  }

  const zTensor = mm.tf.tensor2d([avg], [1, zDim]);
  const decoded = await vae.decode(zTensor, opts.temperature ?? 0.5);
  zTensor.dispose();

  return nsToPattern(decoded[0]);
}
</file>

<file path="src/lib/firebase.js">
import { initializeApp, getApps } from 'firebase/app';
import { getAuth } from 'firebase/auth';
import { getFirestore } from 'firebase/firestore';
import { getStorage } from 'firebase/storage';

const firebaseConfig = {
  apiKey: process.env.REACT_APP_FIREBASE_API_KEY,
  authDomain: process.env.REACT_APP_FIREBASE_AUTH_DOMAIN,
  projectId: process.env.REACT_APP_FIREBASE_PROJECT_ID,
  storageBucket: process.env.REACT_APP_FIREBASE_STORAGE_BUCKET,
  messagingSenderId: process.env.REACT_APP_FIREBASE_MESSAGING_SENDER_ID,
  appId: process.env.REACT_APP_FIREBASE_APP_ID,
  measurementId: process.env.REACT_APP_FIREBASE_MEASUREMENT_ID,
};

// Guard against missing configuration in development to avoid silent failures.
const missingKeys = Object.entries(firebaseConfig)
  .filter(([, value]) => !value)
  .map(([key]) => key);

if (missingKeys.length) {
  console.warn(
    '[firebase] Missing environment variables:',
    missingKeys.join(', ')
  );
}

const app = getApps().length ? getApps()[0] : initializeApp(firebaseConfig);

export const auth = getAuth(app);
export const db = getFirestore(app);
export const storage = getStorage(app);
export default app;
</file>

<file path="src/lib/magentaCompat.js">
// src/lib/magentaCompat.js

let _mmPromise = null;

export async function loadMagenta() {
  if (!_mmPromise) {

    _mmPromise = import('@magenta/music/es6');
  }
  return _mmPromise;
}
</file>

<file path="src/lib/toneCompat.js">
// src/lib/toneCompat.js
let toneModulePromise;

/** Tone.js를 동적으로 로드 (v14는 default export 없음) */
export async function getTone() {
  if (!toneModulePromise) {
    toneModulePromise = import('tone'); // <- 항상 모듈 네임스페이스 객체를 받음
  }
  return toneModulePromise;
}

/** 유저 제스처 후 오디오 시작(필요할 때만 호출) */
export async function ensureAudioStart(toneModule) {
  const Tone = toneModule || (await getTone());
  try {
    await Tone.start(); // 크롬/사파리에서 사용자 제스처 필요
  } catch (_) {}
  return Tone.context.state === 'running';
}
</file>

<file path="src/logo.svg">
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 841.9 595.3"><g fill="#61DAFB"><path d="M666.3 296.5c0-32.5-40.7-63.3-103.1-82.4 14.4-63.6 8-114.2-20.2-130.4-6.5-3.8-14.1-5.6-22.4-5.6v22.3c4.6 0 8.3.9 11.4 2.6 13.6 7.8 19.5 37.5 14.9 75.7-1.1 9.4-2.9 19.3-5.1 29.4-19.6-4.8-41-8.5-63.5-10.9-13.5-18.5-27.5-35.3-41.6-50 32.6-30.3 63.2-46.9 84-46.9V78c-27.5 0-63.5 19.6-99.9 53.6-36.4-33.8-72.4-53.2-99.9-53.2v22.3c20.7 0 51.4 16.5 84 46.6-14 14.7-28 31.4-41.3 49.9-22.6 2.4-44 6.1-63.6 11-2.3-10-4-19.7-5.2-29-4.7-38.2 1.1-67.9 14.6-75.8 3-1.8 6.9-2.6 11.5-2.6V78.5c-8.4 0-16 1.8-22.6 5.6-28.1 16.2-34.4 66.7-19.9 130.1-62.2 19.2-102.7 49.9-102.7 82.3 0 32.5 40.7 63.3 103.1 82.4-14.4 63.6-8 114.2 20.2 130.4 6.5 3.8 14.1 5.6 22.5 5.6 27.5 0 63.5-19.6 99.9-53.6 36.4 33.8 72.4 53.2 99.9 53.2 8.4 0 16-1.8 22.6-5.6 28.1-16.2 34.4-66.7 19.9-130.1 62-19.1 102.5-49.9 102.5-82.3zm-130.2-66.7c-3.7 12.9-8.3 26.2-13.5 39.5-4.1-8-8.4-16-13.1-24-4.6-8-9.5-15.8-14.4-23.4 14.2 2.1 27.9 4.7 41 7.9zm-45.8 106.5c-7.8 13.5-15.8 26.3-24.1 38.2-14.9 1.3-30 2-45.2 2-15.1 0-30.2-.7-45-1.9-8.3-11.9-16.4-24.6-24.2-38-7.6-13.1-14.5-26.4-20.8-39.8 6.2-13.4 13.2-26.8 20.7-39.9 7.8-13.5 15.8-26.3 24.1-38.2 14.9-1.3 30-2 45.2-2 15.1 0 30.2.7 45 1.9 8.3 11.9 16.4 24.6 24.2 38 7.6 13.1 14.5 26.4 20.8 39.8-6.3 13.4-13.2 26.8-20.7 39.9zm32.3-13c5.4 13.4 10 26.8 13.8 39.8-13.1 3.2-26.9 5.9-41.2 8 4.9-7.7 9.8-15.6 14.4-23.7 4.6-8 8.9-16.1 13-24.1zM421.2 430c-9.3-9.6-18.6-20.3-27.8-32 9 .4 18.2.7 27.5.7 9.4 0 18.7-.2 27.8-.7-9 11.7-18.3 22.4-27.5 32zm-74.4-58.9c-14.2-2.1-27.9-4.7-41-7.9 3.7-12.9 8.3-26.2 13.5-39.5 4.1 8 8.4 16 13.1 24 4.7 8 9.5 15.8 14.4 23.4zM420.7 163c9.3 9.6 18.6 20.3 27.8 32-9-.4-18.2-.7-27.5-.7-9.4 0-18.7.2-27.8.7 9-11.7 18.3-22.4 27.5-32zm-74 58.9c-4.9 7.7-9.8 15.6-14.4 23.7-4.6 8-8.9 16-13 24-5.4-13.4-10-26.8-13.8-39.8 13.1-3.1 26.9-5.8 41.2-7.9zm-90.5 125.2c-35.4-15.1-58.3-34.9-58.3-50.6 0-15.7 22.9-35.6 58.3-50.6 8.6-3.7 18-7 27.7-10.1 5.7 19.6 13.2 40 22.5 60.9-9.2 20.8-16.6 41.1-22.2 60.6-9.9-3.1-19.3-6.5-28-10.2zM310 490c-13.6-7.8-19.5-37.5-14.9-75.7 1.1-9.4 2.9-19.3 5.1-29.4 19.6 4.8 41 8.5 63.5 10.9 13.5 18.5 27.5 35.3 41.6 50-32.6 30.3-63.2 46.9-84 46.9-4.5-.1-8.3-1-11.3-2.7zm237.2-76.2c4.7 38.2-1.1 67.9-14.6 75.8-3 1.8-6.9 2.6-11.5 2.6-20.7 0-51.4-16.5-84-46.6 14-14.7 28-31.4 41.3-49.9 22.6-2.4 44-6.1 63.6-11 2.3 10.1 4.1 19.8 5.2 29.1zm38.5-66.7c-8.6 3.7-18 7-27.7 10.1-5.7-19.6-13.2-40-22.5-60.9 9.2-20.8 16.6-41.1 22.2-60.6 9.9 3.1 19.3 6.5 28.1 10.2 35.4 15.1 58.3 34.9 58.3 50.6-.1 15.7-23 35.6-58.4 50.6zM320.8 78.4z"/><circle cx="420.9" cy="296.5" r="45.7"/><path d="M520.5 78.1z"/></g></svg>
</file>

<file path="src/pages/Auth.js">
import React, { useMemo, useState, useEffect } from 'react';
import {
  Box,
  Button,
  Container,
  Paper,
  Stack,
  Tab,
  Tabs,
  TextField,
  Typography,
  Alert,
} from '@mui/material';
import { useNavigate, useLocation } from 'react-router-dom';

import { useMusicContext } from '../context/MusicContext';

const colors = {
  background: '#050505',
  backgroundSoft: '#060708',
  cardBg: '#101416',
  accent: '#2DD4BF',
  accentDark: '#1AA38E',
  border: '#1F2A2E',
  text: '#FFFFFF',
  textMuted: '#8FA3B5',
};

function TabPanel({ value, index, children }) {
  if (value !== index) return null;
  return (
    <Box sx={{ mt: 3 }}>
      {children}
    </Box>
  );
}

export default function AuthPage() {
  const navigate = useNavigate();
  const location = useLocation();
  const { state, actions } = useMusicContext();
  const authState = state.auth;
  const isLoading = authState.status === 'loading';
  const [tab, setTab] = useState(0);
  const [signUpForm, setSignUpForm] = useState({ displayName: '', email: '', password: '' });
  const [loginForm, setLoginForm] = useState({ email: '', password: '' });
  const [localError, setLocalError] = useState('');
  const textFieldStyles = useMemo(
    () => ({
      '& .MuiOutlinedInput-root': {
        bgcolor: '#12181B',
        borderRadius: 2,
        color: colors.text,
        transition: 'border-color 0.2s ease, box-shadow 0.2s ease',
        '& input': { color: colors.text },
        '& fieldset': { borderColor: colors.border },
        '&:hover fieldset': { borderColor: colors.accent },
        '&.Mui-focused fieldset': { borderColor: colors.accent },
      },
      '& .MuiInputLabel-root': { color: colors.textMuted },
      '& .MuiInputLabel-root.Mui-focused': { color: colors.accent },
    }),
    []
  );

  const gradient = useMemo(
    () =>
      [
        'radial-gradient(55% 60% at 20% 20%, rgba(45,212,191,0.18), rgba(4,8,8,0) 70%)',
        'radial-gradient(45% 55% at 80% 15%, rgba(32,178,170,0.1), rgba(0,0,0,0) 72%)',
        'linear-gradient(145deg, #050505 0%, #040606 45%, #000000 100%)',
      ].join(', '),
    []
  );

  useEffect(() => {
    if (authState.user) {
      navigate('/library', { replace: true });
    }
  }, [authState.user, navigate]);

  const handleSignUp = async (e) => {
    e.preventDefault();
    setLocalError('');
    const { email, password, displayName } = signUpForm;
    if (!email || !password || !displayName) {
      setLocalError('이름, 이메일, 비밀번호를 모두 입력해주세요.');
      return;
    }
    try {
      await actions.signUpWithEmail({ email, password, displayName });
    } catch (error) {
      // 이미 컨텍스트에서 에러를 처리하지만, 폼에서도 안내 유지
      setLocalError(error?.message || '회원가입에 실패했어요.');
    }
  };

  const handleLogin = async (e) => {
    e.preventDefault();
    setLocalError('');
    const { email, password } = loginForm;
    if (!email || !password) {
      setLocalError('이메일과 비밀번호를 입력해주세요.');
      return;
    }
    try {
      await actions.signInWithEmail({ email, password });
    } catch (error) {
      setLocalError(error?.message || '로그인에 실패했어요.');
    }
  };

  const redirectFrom = location.state?.from;
  const errorMessage = localError || authState.error;

  return (
    <Box
      sx={{
        minHeight: '100vh',
        position: 'relative',
        bgcolor: colors.background,
        display: 'flex',
        alignItems: 'center',
        py: { xs: 6, md: 10 },
        backgroundImage: gradient,
        '&::after': {
          content: '""',
          position: 'absolute',
          inset: 0,
          background: 'radial-gradient(50% 35% at 60% 95%, rgba(45,212,191,0.1), rgba(0,0,0,0) 75%)',
          pointerEvents: 'none',
        },
      }}
    >
      <Container maxWidth="sm">
        <Paper
          elevation={10}
          sx={{
            position: 'relative',
            bgcolor: colors.cardBg,
            color: colors.text,
            borderRadius: 4,
            border: `1px solid ${colors.border}`,
            boxShadow: `0 25px 55px rgba(0,0,0,0.6), 0 0 35px rgba(45,212,191,0.18)`,
            overflow: 'hidden',
          }}
        >
          <Box sx={{ p: { xs: 4, md: 6 } }}>
            <Typography variant="h4" sx={{ fontWeight: 700, textAlign: 'center', mb: 1 }}>
              AI MUSE
            </Typography>
            <Typography sx={{ color: colors.textMuted, textAlign: 'center', mb: 4 }}>
              나만의 음악을 저장하고 공유하려면 먼저 로그인하세요.
            </Typography>

            <Tabs
              value={tab}
              onChange={(_, value) => {
                setTab(value);
                setLocalError('');
              }}
              variant="fullWidth"
              textColor="inherit"
              TabIndicatorProps={{ style: { backgroundColor: colors.accent } }}
              sx={{
                '& .MuiTab-root': {
                  color: colors.textMuted,
                  fontWeight: 600,
                  textTransform: 'none',
                },
                '& .Mui-selected': {
                  color: colors.text,
                },
              }}
            >
              <Tab label="로그인" />
              <Tab label="회원가입" />
            </Tabs>

            {redirectFrom && !authState.user && (
              <Alert
                severity="info"
                sx={{
                  mt: 3,
                  bgcolor: 'rgba(45,212,191,0.12)',
                  color: colors.accent,
                  borderRadius: 2,
                  border: '1px solid rgba(45,212,191,0.35)',
                  fontWeight: 500,
                }}
              >
                {redirectFrom === '/library'
                  ? '라이브러리는 로그인 후 이용할 수 있어요.'
                  : '이 페이지는 로그인 후 이용할 수 있어요.'}
              </Alert>
            )}

            {errorMessage && (
              <Alert
                severity="error"
                sx={{
                  mt: 3,
                  bgcolor: 'rgba(239,68,68,0.12)',
                  color: '#FCA5A5',
                  borderRadius: 2,
                  border: '1px solid rgba(239,68,68,0.35)',
                }}
              >
                {errorMessage}
              </Alert>
            )}

            <TabPanel value={tab} index={0}>
              <Box component="form" onSubmit={handleLogin} noValidate>
                <Stack spacing={3}>
                  <TextField
                    label="이메일"
                    type="email"
                    fullWidth
                    value={loginForm.email}
                    onChange={(e) => setLoginForm((prev) => ({ ...prev, email: e.target.value }))}
                    sx={textFieldStyles}
                  />
                  <TextField
                    label="비밀번호"
                    type="password"
                    fullWidth
                    value={loginForm.password}
                    onChange={(e) => setLoginForm((prev) => ({ ...prev, password: e.target.value }))}
                    sx={textFieldStyles}
                  />
                  <Button
                    type="submit"
                    fullWidth
                    size="large"
                    disabled={isLoading}
                    sx={{
                      mt: 1,
                      py: 1.5,
                      fontWeight: 700,
                      borderRadius: 999,
                      bgcolor: colors.accent,
                      color: '#041311',
                      '&:hover': {
                        bgcolor: colors.accentDark,
                      },
                      '&:disabled': {
                        bgcolor: '#1f3a36',
                        color: '#6fbfb0',
                      },
                    }}
                  >
                    {isLoading ? '로그인 중...' : '로그인'}
                  </Button>
                </Stack>
              </Box>
            </TabPanel>

            <TabPanel value={tab} index={1}>
              <Box component="form" onSubmit={handleSignUp} noValidate>
                <Stack spacing={3}>
                  <TextField
                    label="닉네임"
                    fullWidth
                    value={signUpForm.displayName}
                    onChange={(e) => setSignUpForm((prev) => ({ ...prev, displayName: e.target.value }))}
                    sx={textFieldStyles}
                  />
                  <TextField
                    label="이메일"
                    type="email"
                    fullWidth
                    value={signUpForm.email}
                    onChange={(e) => setSignUpForm((prev) => ({ ...prev, email: e.target.value }))}
                    sx={textFieldStyles}
                  />
                  <TextField
                    label="비밀번호"
                    type="password"
                    fullWidth
                    value={signUpForm.password}
                    onChange={(e) => setSignUpForm((prev) => ({ ...prev, password: e.target.value }))}
                    sx={textFieldStyles}
                  />
                  <Typography variant="caption" sx={{ color: colors.textMuted }}>
                    최소 6자 이상의 비밀번호를 사용해주세요.
                  </Typography>
                  <Button
                    type="submit"
                    fullWidth
                    size="large"
                    disabled={isLoading}
                    sx={{
                      mt: 1,
                      py: 1.5,
                      fontWeight: 700,
                      borderRadius: 999,
                      bgcolor: colors.accent,
                      color: '#041311',
                      '&:hover': {
                        bgcolor: colors.accentDark,
                      },
                      '&:disabled': {
                        bgcolor: '#1f3a36',
                        color: '#6fbfb0',
                      },
                    }}
                  >
                    {isLoading ? '가입 중...' : '회원가입'}
                  </Button>
                </Stack>
              </Box>
            </TabPanel>

            <Typography sx={{ mt: 6, fontSize: 12, color: colors.textMuted, textAlign: 'center' }}>
              음악 생성 기능은 로그인 없이도 체험할 수 있지만, 저장과 라이브러리 기능은 계정이 필요해요.
            </Typography>
          </Box>
        </Paper>
      </Container>
    </Box>
  );
}
</file>

<file path="src/pages/Library.js">
import React from 'react';
import {
  Container,
  Box,
  Typography,
  Paper,
  Button,
  Grid,
  Card,
  CardContent,
  CardActions,
  IconButton,
  Chip,
  TextField,
  InputAdornment,
  Select,
  MenuItem,
  FormControl,
  InputLabel,
  CircularProgress,
} from '@mui/material';
import { 
  Search,
  PlayArrow,
  Download,
  Delete,
  Favorite,
  MusicNote
} from '@mui/icons-material';

import { useMusicContext } from '../context/MusicContext';
import { GENRE_OPTIONS } from '../components/common/GenreSelector';

const Library = () => {
  const { state, actions } = useMusicContext();
  const [searchQuery, setSearchQuery] = React.useState('');
  const [sortBy, setSortBy] = React.useState('date');
  const [filterBy, setFilterBy] = React.useState('all');

  const { musicList, loading, error } = state.library;

  // 장르 정보 가져오기
  const getGenreInfo = (genreId) => {
    return GENRE_OPTIONS.find(g => g.id === genreId) || { label: genreId, color: '#6366F1' };
  };

  // 시간 포맷팅
  const formatTime = (seconds) => {
    const mins = Math.floor(seconds / 60);
    const secs = Math.floor(seconds % 60);
    return `${mins}:${secs.toString().padStart(2, '0')}`;
  };

  // 필터링 및 정렬된 음악 리스트
  const getCreatedAt = (item) => {
    if (!item?.createdAt) return 0;
    if (typeof item.createdAt === 'string') {
      return new Date(item.createdAt).getTime() || 0;
    }
    if (item.createdAt?.toMillis) {
      return item.createdAt.toMillis();
    }
    return Number(item.createdAt) || 0;
  };

  const filteredAndSortedMusic = musicList
    .filter((music) => {
      // 검색 필터
      if (searchQuery && !music.title.toLowerCase().includes(searchQuery.toLowerCase())) {
        return false;
      }
      
      // 타입 필터
      if (filterBy !== 'all' && music.type !== filterBy) {
        return false;
      }
      
      return true;
    })
    .sort((a, b) => {
      switch (sortBy) {
        case 'date':
          return getCreatedAt(b) - getCreatedAt(a);
        case 'title':
          return a.title.localeCompare(b.title);
        case 'duration':
          return b.duration - a.duration;
        case 'favorites':
          return b.isFavorite - a.isFavorite;
        default:
          return 0;
      }
    });

  // 이벤트 핸들러들
  const handlePlay = (music) => {
    actions.addNotification({
      type: 'info',
      message: `"${music.title}" 재생을 시작합니다.`
    });
  };

  const handleDownload = (music) => {
    actions.addNotification({
      type: 'success',
      message: `"${music.title}" 다운로드가 시작되었습니다.`
    });
  };

  const handleDelete = (musicId) => {
    actions.addNotification({
      type: 'success',
      message: '음악이 라이브러리에서 제거되었습니다.'
    });
  };

  const handleToggleFavorite = (musicId) => {
    actions.addNotification({
      type: 'info',
      message: '즐겨찾기 상태가 변경되었습니다.'
    });
  };

  // 검은색 배경에 에메랄드 테마
  const colors = {
    background: '#0A0A0A',         // 검은색 배경
    cardBg: '#1A1A1A',            // 어두운 카드 배경
    primary: '#50E3C2',           // 에메랄드 (Emerald)
    secondary: '#40D9B8',         // 연한 에메랄드
    accent: '#2DD4BF',            // 터콰이즈 (Teal)
    text: '#FFFFFF',              // 흰색 텍스트
    textLight: '#CCCCCC',         // 연한 회색 텍스트
    border: '#333333',            // 어두운 테두리
    shadow: 'rgba(80, 227, 194, 0.3)' // 에메랄드 그림자
  };

  return (
    <Box sx={{ 
      minHeight: '100vh', 
      bgcolor: colors.background,
      backgroundImage: 'linear-gradient(135deg, #0A0A0A 0%, #1A1A1A 100%)'
    }}>
      <Container maxWidth="xl" sx={{ py: 6 }}>
        {/* 페이지 헤더 */}
        <Box sx={{ mb: 6, textAlign: 'center' }}>
          
          <Typography 
            variant="h2" 
            component="h1"
            sx={{ 
              fontWeight: 700,
              color: colors.text,
              mb: 2
            }}
          >
            라이브러리
          </Typography>
          
          <Typography 
            variant="h6" 
            sx={{ 
              color: colors.textLight,
              maxWidth: 600,
              mx: 'auto',
              lineHeight: 1.6
            }}
          >
            생성하고 변환한 음악들을 관리하세요
          </Typography>
        </Box>

        {/* 검색 및 필터 */}
        <Paper 
          elevation={0}
          sx={{ 
            p: 4, 
            mb: 4,
            bgcolor: colors.cardBg,
            border: `1px solid ${colors.border}`,
            borderRadius: 3,
            boxShadow: `0 4px 20px ${colors.shadow}`
          }}
        >
          <Grid container spacing={3} alignItems="center">
            <Grid item xs={12} md={4}>
              <TextField
                fullWidth
                value={searchQuery}
                onChange={(e) => setSearchQuery(e.target.value)}
                placeholder="음악 제목으로 검색..."
                InputProps={{
                  startAdornment: (
                    <InputAdornment position="start">
                      <Search sx={{ color: colors.textLight }} />
                    </InputAdornment>
                  ),
                }}
                sx={{
                  '& .MuiOutlinedInput-root': {
                    borderRadius: 2,
                    color: colors.text,
                    '& fieldset': {
                      borderColor: colors.border,
                    },
                    '&:hover fieldset': {
                      borderColor: colors.primary,
                    },
                    '&.Mui-focused fieldset': {
                      borderColor: colors.primary,
                    },
                  },
                  '& .MuiInputBase-input::placeholder': {
                    color: colors.textLight,
                    opacity: 1,
                  },
                }}
              />
            </Grid>
            
            <Grid item xs={12} md={4}>
              <FormControl fullWidth>
                <InputLabel sx={{ color: colors.textLight, '&.Mui-focused': { color: colors.primary } }}>정렬 기준</InputLabel>
                <Select
                  value={sortBy}
                  onChange={(e) => setSortBy(e.target.value)}
                  MenuProps={{
                    PaperProps: {
                      sx: {
                        bgcolor: colors.cardBg,
                        border: `1px solid ${colors.border}`,
                        '& .MuiMenuItem-root': {
                          color: colors.text,
                          '&:hover': {
                            bgcolor: colors.border,
                          },
                          '&.Mui-selected': {
                            bgcolor: colors.primary,
                            color: '#000000',
                            '&:hover': {
                              bgcolor: colors.primary,
                            },
                          },
                        },
                      },
                    },
                  }}
                  sx={{
                    borderRadius: 2,
                    color: colors.text,
                    '& .MuiOutlinedInput-notchedOutline': {
                      borderColor: colors.border,
                    },
                    '&:hover .MuiOutlinedInput-notchedOutline': {
                      borderColor: colors.primary,
                    },
                    '&.Mui-focused .MuiOutlinedInput-notchedOutline': {
                      borderColor: colors.primary,
                    },
                  }}
                >
                  <MenuItem value="date">최신순</MenuItem>
                  <MenuItem value="title">제목순</MenuItem>
                  <MenuItem value="duration">재생시간</MenuItem>
                  <MenuItem value="favorites">즐겨찾기</MenuItem>
                </Select>
              </FormControl>
            </Grid>
            
            <Grid item xs={12} md={4}>
              <FormControl fullWidth>
                <InputLabel sx={{ color: colors.textLight, '&.Mui-focused': { color: colors.primary } }}>필터</InputLabel>
                <Select
                  value={filterBy}
                  onChange={(e) => setFilterBy(e.target.value)}
                  MenuProps={{
                    PaperProps: {
                      sx: {
                        bgcolor: colors.cardBg,
                        border: `1px solid ${colors.border}`,
                        '& .MuiMenuItem-root': {
                          color: colors.text,
                          '&:hover': {
                            bgcolor: colors.border,
                          },
                          '&.Mui-selected': {
                            bgcolor: colors.primary,
                            color: '#000000',
                            '&:hover': {
                              bgcolor: colors.primary,
                            },
                          },
                        },
                      },
                    },
                  }}
                  sx={{
                    borderRadius: 2,
                    color: colors.text,
                    '& .MuiOutlinedInput-notchedOutline': {
                      borderColor: colors.border,
                    },
                    '&:hover .MuiOutlinedInput-notchedOutline': {
                      borderColor: colors.primary,
                    },
                    '&.Mui-focused .MuiOutlinedInput-notchedOutline': {
                      borderColor: colors.primary,
                    },
                  }}
                >
                  <MenuItem value="all">전체</MenuItem>
                  <MenuItem value="generated">생성된 음악</MenuItem>
                  <MenuItem value="converted">변환된 음악</MenuItem>
                </Select>
              </FormControl>
            </Grid>
          </Grid>
        </Paper>

        {/* 음악 리스트 */}
        {loading ? (
          <Box sx={{ textAlign: 'center', py: 8 }}>
            <CircularProgress sx={{ color: colors.accent }} />
            <Typography variant="body1" color={colors.textLight} sx={{ mt: 2 }}>
              라이브러리를 불러오는 중이에요...
            </Typography>
          </Box>
        ) : error ? (
          <Box sx={{ textAlign: 'center', py: 8 }}>
            <Typography variant="h5" color="#FCA5A5" sx={{ mb: 1 }}>
              데이터를 불러오지 못했어요
            </Typography>
            <Typography variant="body1" color={colors.textLight}>
              잠시 후 다시 시도해주세요.
            </Typography>
          </Box>
        ) : filteredAndSortedMusic.length === 0 ? (
          <Box sx={{ textAlign: 'center', py: 8 }}>
            <MusicNote sx={{ fontSize: '4rem', color: colors.textLight, mb: 2 }} />
            <Typography variant="h5" color={colors.textLight} sx={{ mb: 1 }}>
              저장된 곡이 아직 없어요
            </Typography>
            <Typography variant="body1" color={colors.textLight}>
              음악을 생성하거나 비트를 만들어 저장해보세요!
            </Typography>
          </Box>
        ) : (
          <Grid container spacing={3}>
            {filteredAndSortedMusic.map((music) => (
              <Grid item xs={12} sm={6} md={4} lg={3} key={music.id}>
                <Card 
                  elevation={0}
                  sx={{ 
                    height: '100%',
                    display: 'flex',
                    flexDirection: 'column',
                    bgcolor: colors.cardBg,
                    border: `1px solid ${colors.border}`,
                    borderRadius: 3,
                    boxShadow: `0 4px 20px ${colors.shadow}`,
                    transition: 'all 0.3s ease-in-out',
                    '&:hover': {
                      transform: 'translateY(-4px)',
                      boxShadow: `0 8px 30px ${colors.shadow}`
                    }
                  }}
                >
                  <CardContent sx={{ flexGrow: 1, p: 3 }}>
                    {/* 타입 표시 */}
                    <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'flex-start', mb: 2 }}>
                      <Chip 
                        label={music.type === 'generated' ? '생성됨' : '변환됨'}
                        size="small"
                        sx={{
                          bgcolor: music.type === 'generated' ? '#1A1A1A' : '#1A1A1A',
                          color: music.type === 'generated' ? '#FFD700' : '#DAA520',
                          fontWeight: 700,
                          fontSize: '0.75rem',
                          border: `2px solid ${music.type === 'generated' ? '#FFD700' : '#DAA520'}`
                        }}
                      />
                      <IconButton
                        size="small"
                        onClick={() => handleToggleFavorite(music.id)}
                        sx={{ 
                          color: music.isFavorite ? colors.warning : colors.textLight,
                          '&:hover': {
                            bgcolor: music.isFavorite ? '#FFF8E1' : colors.border
                          }
                        }}
                      >
                        <Favorite />
                      </IconButton>
                    </Box>

                    {/* 제목 */}
                    <Typography 
                      variant="h6" 
                      component="h3"
                      sx={{ 
                        fontWeight: 600,
                        color: colors.text,
                        mb: 2,
                        overflow: 'hidden',
                        textOverflow: 'ellipsis',
                        whiteSpace: 'nowrap'
                      }}
                    >
                      {music.title}
                    </Typography>

                    {/* 장르/분위기 태그 */}
                    <Box sx={{ display: 'flex', flexWrap: 'wrap', gap: 0.5, mb: 2 }}>
                      {music.genres && music.genres.map((genre) => {
                        const genreInfo = getGenreInfo(genre);
                        return (
                          <Chip
                            key={genre}
                            label={genreInfo.label}
                            size="small"
                            sx={{
                              bgcolor: colors.border,
                              color: colors.text,
                              fontSize: '0.75rem'
                            }}
                          />
                        );
                      })}
                      {music.targetGenre && (
                        <Chip
                          label={getGenreInfo(music.targetGenre).label}
                          size="small"
                          sx={{
                            bgcolor: colors.border,
                            color: colors.text,
                            fontSize: '0.75rem'
                          }}
                        />
                      )}
                    </Box>

                    {/* 재생시간 */}
                    <Typography variant="body2" color={colors.textLight}>
                      {formatTime(music.duration)}
                    </Typography>
                  </CardContent>

                  <CardActions sx={{ p: 2, pt: 0 }}>
                    <Button
                      startIcon={<PlayArrow />}
                      onClick={() => handlePlay(music)}
                      sx={{
                        color: colors.primary,
                        '&:hover': {
                          bgcolor: '#F3F4FF'
                        }
                      }}
                    >
                      재생
                    </Button>
                    <Button
                      startIcon={<Download />}
                      onClick={() => handleDownload(music)}
                      sx={{
                        color: colors.accent,
                        '&:hover': {
                          bgcolor: '#F0FDFC'
                        }
                      }}
                    >
                      다운로드
                    </Button>
                    <IconButton
                      onClick={() => handleDelete(music.id)}
                      sx={{
                        color: colors.textLight,
                        ml: 'auto',
                        '&:hover': {
                          bgcolor: '#FFEBEE',
                          color: '#F44336'
                        }
                      }}
                    >
                      <Delete />
                    </IconButton>
                  </CardActions>
                </Card>
              </Grid>
            ))}
          </Grid>
        )}
      </Container>
    </Box>
  );
};

export default Library;
</file>

<file path="src/pages/MusicConversion.js">
// src/pages/MusicConversion.js

import React, { useRef, useState } from 'react';
import { Box, Button, ButtonGroup, Container, Grid, Paper, Stack, Typography } from '@mui/material';
import MusicNote from '@mui/icons-material/MusicNote';

import { BeatPadProvider } from '../state/beatPadStore';
import { useBeatMakerEngine } from '../hooks/useBeatMakerEngine';
import TransportBar from '../components/beat/TransportBar';
import BeatGrid from '../components/beat/BeatGrid';
import BlendPad from '../components/beat/BlendPad';
import { clonePattern } from '../components/beat/presets';
import PadToolbar from '../components/beat/PadToolbar';
import PathOverlay from '../components/beat/PathOverlay';
import BlendPadCanvas from '../components/beat/BlendPadCanvas';

const colors = {
  background: '#0A0A0A',
  cardBg: '#1A1A1A',
  primary: '#50E3C2',
  accent: '#2DD4BF',
  text: '#FFFFFF',
  textLight: '#CCCCCC',
  border: '#333333',
  shadow: 'rgba(80, 227, 194, 0.35)',
};

function BeatMaker() {
  const { state, actions } = useBeatMakerEngine();

  const handleToggle = (track, step) => {
    if (state.mode === 'EDIT') {
      actions.updateEditingPattern(track, step);
      return;
    }
    const newPattern = clonePattern(state.pattern);
    newPattern[track][step] = !newPattern[track][step];
    actions.setPattern(newPattern);
  };

  const displayedPattern =
    state.mode === 'EDIT' && state.selectedCorner
      ? state.cornerPatterns[state.selectedCorner]
      : state.pattern;

  const buttonStyles = {
    contained: {
      bgcolor: '#2DD4BF',
      color: '#0A0A0A',
      fontWeight: 600,
      '&:hover': {
        bgcolor: '#28bfa8',
      },
    },
    outlined: {
      borderColor: '#2DD4BF',
      color: '#2DD4BF',
      fontWeight: 600,
      '&:hover': {
        borderColor: '#2DD4BF',
        backgroundColor: 'rgba(45, 212, 191, 0.1)',
      },
    },
  };

  const drawingPathRef = useRef([]);
  const [isDrawing, setIsDrawing] = useState(false);

  return (
    <Box sx={{ minHeight: '100vh', bgcolor: colors.background, pt: 4, pb: 4 }}>
      <Container maxWidth="xl">
        <Typography
          variant="h4"
          sx={{
            color: colors.text,
            fontWeight: 800,
            mb: 2,
            display: 'flex',
            alignItems: 'center',
          }}
        >
          <MusicNote sx={{ mr: 1, color: colors.accent }} />
          비트 만들기
        </Typography>

        <Grid container spacing={3} sx={{ mb: 1 }}>
          <Grid item xs={12}>
            <Paper sx={{ p: 2, bgcolor: colors.cardBg, border: `1px solid ${colors.border}` }}>
              <TransportBar
                bpm={state.bpm}
                onChangeBpm={actions.setBpm}
                onPlay={() => actions.setIsPlaying(true)}
                onStop={() => actions.setIsPlaying(false)}
                onClear={actions.clearPattern}
                onExport={actions.handleExport}
              />
            </Paper>
          </Grid>
        </Grid>

        <Grid container spacing={3}>
          <Grid item xs={12} md={5}>
            <Paper
              sx={{
                p: { xs: 2, md: 3 },
                bgcolor: colors.cardBg,
                border: `1px solid ${colors.border}`,
                display: "flex",
                flexDirection: "column",
                height: "100%",
              }}
            >
              <Typography variant="h6" sx={{ color: colors.text, mb: 2 }}>
                패드 블렌딩
              </Typography>

              {state.mode === "INTERPOLATE" ? (
                <Stack direction="row" spacing={2} sx={{ mb: 2 }}>
                  <Button
                    onClick={() => actions.setDrawMode(state.drawMode === "PATH" ? "DRAG" : "PATH")}
                    variant={state.drawMode === "PATH" ? "contained" : "outlined"}
                    sx={
                      state.drawMode === "PATH"
                        ? buttonStyles.contained
                        : buttonStyles.outlined
                    }
                  >
                    그리기 모드
                  </Button>
                  <Button
                    variant="contained"
                    onClick={() => actions.setMode("EDIT")}
                    sx={buttonStyles.contained}
                  >
                    코너 편집하기
                  </Button>
                </Stack>
              ) : (
                <Box sx={{ mb: 2 }}>
                  <Stack direction="row" spacing={1} sx={{ mb: 2 }}>
                    <Button
                      variant="contained"
                      onClick={actions.handleDoneEditing}
                      disabled={state.isInterpolating}
                      sx={buttonStyles.contained}
                    >
                      {state.isInterpolating ? "계산 중..." : "완료"}
                    </Button>
                    <Button
                      variant="outlined"
                      onClick={() => actions.setMode("INTERPOLATE")}
                      sx={buttonStyles.outlined}
                    >
                      취소
                    </Button>
                  </Stack>
                  <Typography sx={{ color: colors.text, mb: 1 }}>
                    편집할 코너 선택:
                  </Typography>
                  <ButtonGroup size="small">
                    {["A", "B", "C", "D"].map((corner) => (
                      <Button
                        key={corner}
                        variant={state.selectedCorner === corner ? "contained" : "outlined"}
                        onClick={() => actions.selectCorner(corner)}
                        sx={
                          state.selectedCorner === corner
                            ? buttonStyles.contained
                            : buttonStyles.outlined
                        }
                      >
                        코너 {corner}
                      </Button>
                    ))}
                  </ButtonGroup>
                </Box>
              )}

              <Box
                sx={{
                  position: "relative",
                  width: "100%",
                  flexGrow: 1,
                  minHeight: 320,
                  borderRadius: 2,
                  border: `1px solid ${colors.border}`,
                  backgroundImage:
                    "linear-gradient(to right, rgba(255,255,255,0.06) 1px, transparent 1px), linear-gradient(to bottom, rgba(255,255,255,0.06) 1px, transparent 1px)",
                  backgroundSize: "10% 100%, 100% 10%",
                  backgroundColor: "#050505",
                  overflow: "hidden",
                }}
              >
                <BlendPadCanvas
                  onBlend={state.mode === "INTERPOLATE" ? actions.handleBlend : undefined}
                  disabled={state.mode !== "INTERPOLATE"}
                  pathRef={drawingPathRef}
                  onDrawingChange={setIsDrawing}
                />
                <PathOverlay pathRef={drawingPathRef} isDrawing={isDrawing} />
              </Box>
            </Paper>
          </Grid>

          {/* 오른쪽: 드럼 시퀀서 */}
          <Grid item xs={12} md={7}>
            <Paper
              sx={{
                p: { xs: 2, md: 3 },
                bgcolor: colors.cardBg,
                border: `1px solid ${colors.border}`,
                height: '100%',
              }}
            >
              <BeatGrid pattern={displayedPattern} currentStep={state.currentStep} onToggle={handleToggle} />
            </Paper>
          </Grid>
        </Grid>
      </Container>
    </Box>
  );
}

// 페이지 export 부분은 변경 없습니다.
export default function MusicConversionPage() {
  return (
    <BeatPadProvider>
      <BeatMaker />
    </BeatPadProvider>
  );
}
</file>

<file path="src/pages/MusicGeneration.js">
// src/pages/MusicGeneration.js
import React, { useState, useMemo, useEffect } from 'react';
import {
  Container, Box, Typography, Paper, TextField, Button, Grid, LinearProgress
} from '@mui/material';
import { MusicNote, PlayArrow, AutoAwesome, Refresh, UploadFile, Delete } from '@mui/icons-material';
import { useNavigate } from 'react-router-dom';

import GenreCardSelector from '../components/common/GenreCardSelector';
import MoodSelector from '../components/common/MoodSelector';
import { useMusicContext } from '../context/MusicContext';

import { generateAndWait } from '../services/musicApi';
import { saveGeneratedTrack } from '../services/libraryWriter';

const MusicGeneration = () => {
  const navigate = useNavigate();
  const { state, actions } = useMusicContext();

  const colors = {
    background: '#0A0A0A',
    cardBg: '#1A1A1A',
    primary: '#50E3C2',
    secondary: '#40D9B8',
    accent: '#2DD4BF',
    text: '#FFFFFF',
    textLight: '#CCCCCC',
    border: '#333333',
    shadow: 'rgba(80, 227, 194, 0.3)'
  };

  const {
    selectedGenres,
    selectedMoods,
    description,
    duration,
    isGenerating
  } = state.generation;

  const isFormValid = selectedGenres.length > 0 || selectedMoods.length > 0;

  const handleGenreChange = (genres) => actions.setSelectedGenres(genres);
  const handleMoodChange = (moods) => actions.setSelectedMoods(moods);
  const handleDescriptionChange = (e) => actions.setDescription(e.target.value);

  // ⬇️ 오디오 첨부 상태
  const [file, setFile] = useState(null);
  const [audioPreview, setAudioPreview] = useState('');
  const fileInfo = useMemo(
    () => (file ? `${file.name} (${Math.round(file.size / 1024)} KB)` : '첨부 없음'),
    [file]
  );

  const handleFilePick = (e) => {
    const f = e.target.files?.[0];
    if (!f) return;
    if (!f.type.startsWith('audio/')) {
      alert('오디오 파일만 첨부하세요 (wav, mp3 등)');
      e.target.value = '';
      return;
    }
    setFile(f);
    const url = URL.createObjectURL(f);
    setAudioPreview(url);
  };

  const removeFile = () => {
    if (audioPreview) URL.revokeObjectURL(audioPreview);
    setFile(null);
    setAudioPreview('');
  };

  // ✅ Beat Maker에서 'Generate로 보내기'를 눌렀을 때 자동 첨부
  useEffect(() => {
    const dataUrl = sessionStorage.getItem('inlineReferenceAudio');
    if (!dataUrl) return;

    (async () => {
      const res = await fetch(dataUrl);
      const blob = await res.blob();
      const fileFromBeat = new File([blob], 'beat.wav', { type: 'audio/wav' });

      setFile(fileFromBeat);
      const url = URL.createObjectURL(fileFromBeat);
      setAudioPreview(url);

      sessionStorage.removeItem('inlineReferenceAudio'); // 1회성
    })();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  // 프롬프트 조합
  const buildPrompt = () => {
    const g = selectedGenres.join(', ');
    const m = selectedMoods.join(', ');
    return [description, g && `genres: ${g}`, m && `mood: ${m}`]
      .filter(Boolean)
      .join(', ');
  };

  // 생성
  const handleGenerateMusic = async () => {
    if (!isFormValid) {
      actions.addNotification({ type: 'error', message: '장르 또는 분위기를 최소 하나 이상 선택해주세요.' });
      return;
    }
    try {
      actions.startGeneration();
      const prompt = buildPrompt();
      const dur = Number(duration || 30);

      const final = await generateAndWait(
        { description: prompt, genres: selectedGenres, moods: selectedMoods, duration: dur },
        (s) => actions.updateGenerationProgress(s.status && s.status !== 'succeeded' ? 50 : 0),
        file // ✅ 첨부 파일 전달
      );

      const generatedMusic = {
        id: Date.now(),
        title: `AI_Generated_${Date.now()}`,
        genres: selectedGenres,
        moods: selectedMoods,
        description: prompt,
        duration: dur,
        audioUrl: final.result.audioUrl,
        createdAt: new Date().toISOString()
      };

      actions.completeGeneration(generatedMusic);

      const currentUser = state.auth.user;
      if (currentUser) {
        try {
          await saveGeneratedTrack({
            ownerId: currentUser.uid,
            title: generatedMusic.title,
            genres: selectedGenres,
            moods: selectedMoods,
            description: prompt,
            durationSec: dur,
            prompt,
            sourceUrl: final.result.audioUrl,
          });
          actions.addNotification({ type: 'success', message: '음악이 생성되어 라이브러리에 저장되었습니다!' });
        } catch (writeError) {
          console.warn(writeError);
          actions.addNotification({ type: 'warning', message: '생성은 완료했지만 라이브러리에 저장하지 못했습니다.' });
        }
      } else {
        actions.addNotification({ type: 'success', message: '음악이 성공적으로 생성되었습니다! 로그인하면 라이브러리에 저장돼요.' });
      }
      navigate('/result');
    } catch (error) {
      console.error(error);
      actions.setError(error.message || '음악 생성 중 오류가 발생했습니다.');
      actions.addNotification({ type: 'error', message: '음악 생성에 실패했습니다. 다시 시도해주세요.' });
    } finally {
      actions.updateGenerationProgress?.(0);
      actions.setGenerating?.(false);
    }
  };

  return (
    <Box sx={{ minHeight: '100vh', bgcolor: colors.background, py: 6 }}>
      <Container maxWidth="lg">
        {/* 변경점 1: '(Generate)' 텍스트 제거 */}
        <Typography variant="h4" sx={{ color: colors.text, fontWeight: 700, mb: 3, display: 'flex', alignItems: 'center' }}>
          <MusicNote sx={{ mr: 1, color: colors.primary }} />
          생성하기
        </Typography>

        <Grid container spacing={4}>
          {/* 메인 카드 */}
          <Grid item xs={12} md={8}>
            <Paper elevation={0} sx={{ bgcolor: colors.cardBg, p: 4, borderRadius: 3, border: `1px solid ${colors.border}` }}>
              {/* 프롬프트 */}
              <Box sx={{ mb: 4 }}>
                <Typography variant="h6" sx={{ display: 'flex', alignItems: 'center', mb: 2, color: colors.text, fontWeight: 600 }}>
                  <AutoAwesome sx={{ mr: 1, color: colors.primary }} />
                  프롬프트
                </Typography>
                <TextField
                  fullWidth multiline minRows={2}
                  placeholder="예: dreamy lofi hiphop with warm piano"
                  value={description} onChange={handleDescriptionChange}
                  sx={{
                    '& .MuiInputBase-root': { bgcolor: '#111', color: colors.text, borderRadius: 2 },
                    '& .MuiOutlinedInput-notchedOutline': { borderColor: colors.border }
                  }}
                />
              </Box>

              {/* 오디오 첨부 */}
              <Box sx={{ mb: 4 }}>
                <Typography variant="h6" sx={{ display: 'flex', alignItems: 'center', mb: 2, color: colors.text, fontWeight: 600 }}>
                  <UploadFile sx={{ mr: 1, color: colors.primary }} />
                  오디오 첨부 (선택)
                </Typography>

                <Box sx={{
                  display: 'flex', alignItems: 'center', gap: 2, mb: 2,
                  p: 2, borderRadius: 2, border: `1px dashed ${colors.border}`, bgcolor: '#111'
                }}>
                  <Button variant="outlined" component="label" sx={{ color: colors.text, borderColor: colors.border }}>
                    파일 선택
                    <input type="file" hidden accept="audio/*" onChange={handleFilePick} />
                  </Button>
                  <Typography sx={{ color: colors.textLight, flex: 1 }}>{fileInfo}</Typography>
                  {file && (
                    <Button onClick={removeFile} size="small" startIcon={<Delete />} sx={{ color: colors.text }}>
                      제거
                    </Button>
                  )}
                </Box>

                {audioPreview && (
                  <audio controls src={audioPreview} style={{ width: '100%' }} />
                )}
              </Box>

              {/* 장르 / 분위기 */}
              <Box sx={{ mb: 4 }}>
                <Typography variant="h6" sx={{ color: colors.text, fontWeight: 600, mb: 2 }}>장르 선택</Typography>
                <GenreCardSelector selectedGenres={selectedGenres} onGenreChange={handleGenreChange} maxSelection={1} />
              </Box>

              <Box sx={{ mb: 4 }}>
                <Typography variant="h6" sx={{ color: colors.text, fontWeight: 600, mb: 2 }}>분위기 선택</Typography>
                <MoodSelector selectedMoods={selectedMoods} onMoodChange={handleMoodChange} maxSelection={3} />
              </Box>

              {/* 길이 입력 */}
              <Box sx={{ mb: 4 }}>
                {/* 변경점 2: 레이블 및 입력 범위 수정 */}
                <Typography variant="h6" sx={{ color: colors.text, fontWeight: 600, mb: 2 }}>길이 (10초 ~ 30초)</Typography>
                <TextField
                  type="number" value={duration} onChange={(e)=>actions.setDuration(Number(e.target.value || 0))}
                  sx={{ width: 160, '& .MuiInputBase-root': { bgcolor: '#111', color: colors.text, borderRadius: 2 } }}
                  inputProps={{ min: 10, max: 30 }}
                />
              </Box>

              {/* 생성 버튼 */}
              <Button
                fullWidth variant="contained" size="large"
                onClick={handleGenerateMusic} disabled={!isFormValid || isGenerating}
                sx={{
                  py: 2, borderRadius: 2, fontWeight: 600, fontSize: '1.1rem',
                  bgcolor: colors.accent, color: '#000', boxShadow: `0 4px 14px ${colors.shadow}`,
                  '&:hover': { bgcolor: colors.accent, boxShadow: `0 6px 20px ${colors.shadow}` },
                  '&:disabled': { bgcolor: colors.border, color: colors.textLight, boxShadow: 'none' }
                }}
              >
                {isGenerating ? (<><Refresh sx={{ mr: 1, animation: 'spin 1s linear infinite', color: '#000' }} />생성 중...</>) :
                 (<><PlayArrow sx={{ mr: 1, color: '#000' }} />생성하기</>)}
              </Button>

              {/* 변경점 3: 로딩 바 색상 변경 */}
              {isGenerating && (
                <Box sx={{ mt: 2 }}>
                  <LinearProgress sx={{
                    backgroundColor: colors.border,
                    '& .MuiLinearProgress-bar': {
                      backgroundColor: colors.accent
                    }
                  }} />
                </Box>
              )}
            </Paper>
          </Grid>
        </Grid>
      </Container>
    </Box>
  );
};

export default MusicGeneration;
</file>

<file path="src/pages/ResultPage.js">
import React, { useState, useEffect, useRef } from 'react';
import {
  Container, Box, Typography, Paper, Button, Grid, Chip, Alert, IconButton, Slider
} from '@mui/material';
import {
  CheckCircle, PlayArrow, Pause, Download, Refresh, Share, Home, LibraryMusic, VolumeUp, BookmarkBorder
} from '@mui/icons-material';
import { useNavigate } from 'react-router-dom';

import { useMusicContext } from '../context/MusicContext';
import { GENRE_OPTIONS } from '../components/common/GenreSelector';
import { MOOD_OPTIONS } from '../components/common/MoodSelector';
import AudioWaveform from '../components/common/AudioWaveform';

const ResultPage = () => {
  const navigate = useNavigate();
  const { state, actions } = useMusicContext();

  // 디버깅: 현재 상태 확인
  console.log('=== ResultPage 디버깅 ===');
  console.log('전체 state:', state);
  console.log('state.result:', state.result);
  console.log('state.generation:', state.generation);
  console.log('=== ResultPage 상세 디버깅 ===');
  console.log('전체 state:', JSON.stringify(state, null, 2));
  if (state.result) {
    console.log('state.result 키들:', Object.keys(state.result));
    console.log('state.result.convertedMusic:', state.result.convertedMusic);
    console.log('state.result.generatedMusic:', state.result.generatedMusic);
  }
  
  if (state.generation) {
    console.log('state.generation 키들:', Object.keys(state.generation));
    console.log('state.generation.generatedMusic:', state.generation.generatedMusic);
  }
  
  console.log('actions.setResult 함수:', typeof actions.setResult);
  console.log('================================');

  // 오디오 제어용
  const audioRef = useRef(null);
  const [isPlaying, setIsPlaying] = useState(false);
  const [currentTime, setCurrentTime] = useState(0);
  const [duration, setDuration] = useState(180);
  const [volume, setVolume] = useState(70);

  // 결과 데이터 (result > generation 순으로 조회)
  const generatedFromResult = state.result?.generatedMusic;
  const convertedFromResult = state.result?.convertedMusic;
  const generatedFromGeneration = state.generation?.generatedMusic;

  console.log('generatedFromResult:', generatedFromResult);
  console.log('convertedFromResult:', convertedFromResult);
  console.log('generatedFromGeneration:', generatedFromGeneration);

  // localStorage 확인 추가
  const musicData =
    generatedFromResult ||
    convertedFromResult ||
    generatedFromGeneration ||
    (() => {
      const stored = localStorage.getItem('scoreGeneratedMusic');
      if (stored) {
        console.log('localStorage에서 음악 데이터 로드:', JSON.parse(stored));
        // 사용 후 삭제
        localStorage.removeItem('scoreGeneratedMusic');
        return JSON.parse(stored);
      }
      return null;
    })();

  console.log('최종 musicData:', musicData);

  const audioUrl = musicData?.audioUrl || '';
  const isConversion = !!(state.result?.convertedMusic);

  // 색상 테마(원본 유지)
  const colors = {
    background: '#0A0A0A', cardBg: '#1A1A1A', primary: '#50E3C2',
    secondary: '#40D9B8', accent: '#2DD4BF', text: '#FFFFFF',
    textLight: '#CCCCCC', border: '#333333', shadow: 'rgba(80, 227, 194, 0.3)'
  };

  // ------- 훅은 항상 호출되도록! (조건부 호출 금지) -------

  // 오디오 이벤트 연결 + 소스 변경
  useEffect(() => {
    const audio = audioRef.current;
    if (!audio) return;

    audio.src = audioUrl || '';
    const onLoadedMetadata = () => {
      setDuration(isFinite(audio.duration) ? audio.duration : 180);
    };
    const onTimeUpdate = () => setCurrentTime(audio.currentTime || 0);
    const onEnded = () => setIsPlaying(false);

    audio.addEventListener('loadedmetadata', onLoadedMetadata);
    audio.addEventListener('timeupdate', onTimeUpdate);
    audio.addEventListener('ended', onEnded);

    return () => {
      audio.removeEventListener('loadedmetadata', onLoadedMetadata);
      audio.removeEventListener('timeupdate', onTimeUpdate);
      audio.removeEventListener('ended', onEnded);
    };
  }, [audioUrl]);

  // 볼륨 반영
  useEffect(() => {
    if (audioRef.current) audioRef.current.volume = volume / 100;
  }, [volume]);

  // -----------------------------------------------------

  const getGenreInfo = (genreId) =>
    GENRE_OPTIONS.find((g) => g.id === genreId) || { label: genreId, color: '#6366F1' };

  const getMoodInfo = (moodId) =>
    MOOD_OPTIONS.find((m) => m.id === moodId) || { label: moodId, emoji: '🎵' };

  const formatTime = (seconds) => {
    const mins = Math.floor(seconds / 60);
    const secs = Math.floor(seconds % 60);
    return `${mins}:${secs.toString().padStart(2, '0')}`;
  };

  const handlePlayPause = async () => {
    const audio = audioRef.current;
    if (!audio || !audioUrl) return;

    if (!isPlaying) {
      try {
        await audio.play();
        setIsPlaying(true);
        actions.setPlaying?.(true);
      } catch {
        actions.addNotification?.({
          type: 'info',
          message: '브라우저 자동재생이 차단되면 수동으로 재생해야 합니다.'
        });
      }
    } else {
      audio.pause();
      setIsPlaying(false);
      actions.setPlaying?.(false);
    }
  };

  const handleTimeChange = (e, newValue) => {
    setCurrentTime(newValue);
    if (audioRef.current) audioRef.current.currentTime = newValue;
    actions.updateCurrentTime?.(newValue);
  };

  const handleVolumeChange = (e, newValue) => setVolume(newValue);

  const handleDownload = () => {
    try {
      const a = document.createElement('a');
      a.href = audioUrl;
      a.download = (musicData.title || 'music') + '.mp3';
      document.body.appendChild(a);
      a.click();
      a.remove();
      actions.addNotification?.({ type: 'success', message: '다운로드가 시작되었습니다.' });
    } catch {
      actions.addNotification?.({ type: 'error', message: '다운로드에 실패했습니다.' });
    }
  };

  const handleShare = () =>
    actions.addNotification?.({ type: 'info', message: '공유 기능은 추후 업데이트될 예정입니다.' });

  const handleSaveToLibrary = () => {
    actions.addToLibrary?.(musicData);
    actions.addNotification?.({ type: 'success', message: '라이브러리에 추가되었습니다.' });
  };

  const handleRegenerate = () => {
    if (state.result?.generatedMusic || state.generation?.generatedMusic) navigate('/generate');
    else navigate('/convert');
  };

  const hasMusic = !!(musicData && audioUrl);

  console.log('audioUrl:', audioUrl);
  console.log('hasMusic:', hasMusic);
  console.log('=====================');

  return (
    <Box sx={{ minHeight: '100vh', bgcolor: colors.background }}>
      <Container maxWidth="lg" sx={{ py: 6 }}>
        {!hasMusic ? (
          // ===== fallback (이전의 early return을 JSX로 이동) =====
          <Box sx={{ textAlign: 'center' }}>
            <Alert severity="warning" sx={{ mb: 3 }}>
              표시할 음악 데이터가 없습니다.
            </Alert>
            <Button variant="contained" onClick={() => navigate('/')} startIcon={<Home />}>
              홈으로 돌아가기
            </Button>
          </Box>
        ) : (
          // ================= 정상 결과 화면 (디자인 유지) =================
          <>
            {/* 헤더 */}
            <Box sx={{ mb: 6, textAlign: 'center' }}>
              <CheckCircle sx={{ fontSize: '4rem', color: colors.accent, mb: 2 }} />
              <Typography variant="h3" component="h1" sx={{ fontWeight: 600, color: colors.text, mb: 1, letterSpacing: '-0.02em' }}>
                {isConversion ? '음악 변환 완료' : '음악 생성 완료'}
              </Typography>
              <Typography variant="h6" color={colors.textLight} sx={{ fontWeight: 400, opacity: 0.8 }}>
                {isConversion ? '음악이 성공적으로 변환되었습니다' : '새로운 음악이 성공적으로 생성되었습니다'}
              </Typography>
            </Box>

            <Grid container spacing={4}>
              {/* 메인 컨텐츠 */}
              <Grid xs={12} lg={9}>
                {/* 플레이어 카드 */}
                <Paper elevation={0} sx={{ p: 4, border: `1px solid ${colors.border}`, borderRadius: 2, mb: 3, bgcolor: colors.cardBg, color: colors.text }}>
                  <Box sx={{ mb: 3 }}>
                    <Typography variant="h4" fontWeight={600} sx={{ mb: 1, color: colors.text }}>
                      {musicData.title}
                    </Typography>
                    <Typography variant="body1" sx={{ opacity: 0.8, color: colors.textLight }}>
                      {isConversion
                        ? `${musicData.originalFile}을(를) ${musicData.targetGenre} 스타일로 변환했습니다.`
                        : '음악이 성공적으로 생성되었습니다.'}
                    </Typography>
                  </Box>

                  {/* 웨이브폼 */}
                  <Box sx={{ mb: 3 }}>
                    <AudioWaveform
                      isPlaying={isPlaying}
                      progress={(currentTime / duration) * 100}
                      height={100}
                      barCount={80}
                      color={colors.accent}
                    />
                  </Box>

                  {/* 재생 컨트롤 */}
                  <Box sx={{ display: 'flex', alignItems: 'center', gap: 2, mb: 3 }}>
                    <IconButton
                      onClick={handlePlayPause}
                      sx={{ bgcolor: colors.accent, color: colors.background, '&:hover': { bgcolor: colors.text } }}
                      size="large"
                    >
                      {isPlaying ? <Pause /> : <PlayArrow />}
                    </IconButton>

                    <Box sx={{ flexGrow: 1 }}>
                      <Slider
                        value={currentTime}
                        onChange={handleTimeChange}
                        min={0}
                        max={duration}
                        sx={{
                          color: colors.accent,
                          '& .MuiSlider-track': { bgcolor: colors.accent },
                          '& .MuiSlider-thumb': {
                            bgcolor: colors.accent,
                            '&:hover': { boxShadow: `0px 0px 0px 8px ${colors.shadow}` }
                          }
                        }}
                      />
                      <Box sx={{ display: 'flex', justifyContent: 'space-between', mt: 0.5 }}>
                        <Typography variant="caption" sx={{ opacity: 0.8, color: colors.textLight }}>
                          {formatTime(currentTime)}
                        </Typography>
                        <Typography variant="caption" sx={{ opacity: 0.8, color: colors.textLight }}>
                          {formatTime(duration)}
                        </Typography>
                      </Box>
                    </Box>

                    <Box sx={{ display: 'flex', alignItems: 'center', gap: 1, minWidth: 100 }}>
                      <VolumeUp sx={{ opacity: 0.8, color: colors.textLight }} />
                      <Slider
                        value={volume}
                        onChange={handleVolumeChange}
                        min={0}
                        max={100}
                        size="small"
                        sx={{
                          color: colors.accent,
                          '& .MuiSlider-track': { bgcolor: colors.accent },
                          '& .MuiSlider-thumb': { bgcolor: colors.accent }
                        }}
                      />
                    </Box>
                  </Box>

                  {/* 실제 오디오 (숨김) */}
                  <audio ref={audioRef} src={audioUrl} preload="auto" style={{ display: 'none' }} />
                </Paper>

                {/* 정보 카드 */}
                <Paper elevation={0} sx={{ p: 4, border: `1px solid ${colors.border}`, borderRadius: 2, bgcolor: colors.cardBg }}>
                  <Typography variant="h6" fontWeight={600} sx={{ mb: 3, color: colors.text }}>
                    {isConversion ? '변환 정보' : '음악 정보'}
                  </Typography>

                  <Grid container spacing={3}>
                    <Grid xs={12} sm={6}>
                      <Typography variant="subtitle2" sx={{ mb: 1, color: colors.textLight }}>
                        {isConversion ? '변환된 장르' : '장르'}
                      </Typography>
                      <Box sx={{ display: 'flex', flexWrap: 'wrap', gap: 1 }}>
                        {(musicData.genres || [musicData.targetGenre]).filter(Boolean).map((genreId) => {
                          const genre = getGenreInfo(genreId);
                          return (
                            <Chip
                              key={genreId}
                              label={genre.label}
                              size="small"
                              sx={{
                                bgcolor: colors.cardBg,
                                color: colors.primary,
                                border: `1px solid ${colors.primary}`,
                                fontWeight: 600
                              }}
                            />
                          );
                        })}
                      </Box>
                    </Grid>

                    {isConversion && musicData.intensity && (
                      <Grid xs={12} sm={6}>
                        <Typography variant="subtitle2" sx={{ mb: 1, color: colors.textLight }}>
                          변환 강도
                        </Typography>
                        <Typography variant="body2" color={colors.text}>
                          {musicData.intensity}/5
                        </Typography>
                      </Grid>
                    )}

                    {!isConversion && musicData.moods && musicData.moods.length > 0 && (
                      <Grid xs={12} sm={6}>
                        <Typography variant="subtitle2" sx={{ mb: 1, color: colors.textLight }}>
                          분위기
                        </Typography>
                        <Box sx={{ display: 'flex', flexWrap: 'wrap', gap: 1 }}>
                          {musicData.moods.map((moodId) => {
                            const mood = getMoodInfo(moodId);
                            return (
                              <Chip
                                key={moodId}
                                label={`${mood.emoji} ${mood.label}`}
                                size="small"
                                sx={{
                                  bgcolor: colors.cardBg,
                                  color: colors.primary,
                                  border: `1px solid ${colors.primary}`,
                                  fontWeight: 600
                                }}
                              />
                            );
                          })}
                        </Box>
                      </Grid>
                    )}

                    <Grid xs={12} sm={6}>
                      <Typography variant="subtitle2" sx={{ mb: 1, color: colors.textLight }}>
                        길이
                      </Typography>
                      <Typography variant="body2" color={colors.text}>
                        {formatTime(musicData.duration || duration)}
                      </Typography>
                    </Grid>

                    <Grid xs={12} sm={6}>
                      <Typography variant="subtitle2" sx={{ mb: 1, color: colors.textLight }}>
                        생성 시간
                      </Typography>
                      <Typography variant="body2" color={colors.text}>
                        {new Date(musicData.createdAt).toLocaleString('ko-KR')}
                      </Typography>
                    </Grid>
                  </Grid>
                </Paper>
              </Grid>

              {/* 사이드바 */}
              <Grid xs={12} lg={3}>
                <Box sx={{ position: 'sticky', top: 24 }}>
                  <Paper elevation={0} sx={{ p: 4, border: `1px solid ${colors.border}`, borderRadius: 2, bgcolor: colors.cardBg, minHeight: '600px', display: 'flex', flexDirection: 'column' }}>
                    <Box sx={{ display: 'flex', flexDirection: 'column', gap: 3, flex: 1 }}>
                      <Button fullWidth variant="contained" startIcon={<BookmarkBorder />} onClick={handleSaveToLibrary}
                        sx={{ bgcolor: colors.accent, color: colors.background, fontWeight: 600, textTransform: 'none', py: 2, '&:hover': { bgcolor: colors.text } }}>
                        라이브러리에 저장
                      </Button>

                      <Button fullWidth variant="outlined" startIcon={<Download />} onClick={handleDownload}
                        sx={{ color: colors.text, borderColor: colors.border, fontWeight: 600, textTransform: 'none', py: 2, '&:hover': { bgcolor: colors.accent, borderColor: colors.accent, color: colors.background } }}>
                        다운로드
                      </Button>

                      <Button fullWidth variant="outlined" startIcon={<Share />} onClick={handleShare}
                        sx={{ color: colors.text, borderColor: colors.border, fontWeight: 600, textTransform: 'none', py: 2, '&:hover': { bgcolor: colors.accent, borderColor: colors.accent, color: colors.background } }}>
                        공유하기
                      </Button>

                      <Button fullWidth variant="outlined" startIcon={<Refresh />} onClick={handleRegenerate}
                        sx={{ color: colors.text, borderColor: colors.border, fontWeight: 600, textTransform: 'none', py: 2, '&:hover': { bgcolor: colors.accent, borderColor: colors.accent, color: colors.background } }}>
                        다시 {isConversion ? '변환' : '생성'}하기
                      </Button>

                      <Button fullWidth variant="outlined" startIcon={<LibraryMusic />} onClick={() => navigate('/library')}
                        sx={{ color: colors.text, borderColor: colors.border, fontWeight: 600, textTransform: 'none', py: 2, '&:hover': { bgcolor: colors.accent, borderColor: colors.accent, color: colors.background } }}>
                        라이브러리 보기
                      </Button>

                      <Button fullWidth variant="outlined" startIcon={<Home />} onClick={() => navigate('/')}
                        sx={{ color: colors.text, borderColor: colors.border, fontWeight: 600, textTransform: 'none', py: 2, '&:hover': { bgcolor: colors.accent, borderColor: colors.accent, color: colors.background } }}>
                        홈으로 돌아가기
                      </Button>
                    </Box>
                  </Paper>
                </Box>
              </Grid>
            </Grid>
          </>
        )}
      </Container>
    </Box>
  );
};

export default ResultPage;
</file>

<file path="src/pages/ScoreToMusic.js">
// musicgen-app-main/src/pages/ScoreToMusic.js

import React, { useState } from 'react';
import { useNavigate } from 'react-router-dom';
import { useMusicContext } from '../context/MusicContext';
import {
    Typography,
    Button,
    CircularProgress,
    Box,
    MenuItem,
    Select,
    FormControl,
    InputLabel
} from '@mui/material';
import UploadFileIcon from '@mui/icons-material/UploadFile';

const ScoreToMusic = () => {
    const [pdfFile, setPdfFile] = useState(null);
    const [isLoading, setIsLoading] = useState(false);
    const [fileName, setFileName] = useState('');
    const [format, setFormat] = useState('midi'); // 변환 형식 상태
    const navigate = useNavigate();
    
    const { actions } = useMusicContext();

    const handleFileChange = (event) => {
        const file = event.target.files[0];
        if (file && file.type === "application/pdf") {
            setPdfFile(file);
            setFileName(file.name);
        } else {
            alert("PDF 파일만 업로드할 수 있습니다.");
            setPdfFile(null);
            setFileName('');
        }
    };

    const handleFormatChange = (event) => {
        setFormat(event.target.value);
    };

    // 작업 상태 폴링
    const pollTaskStatus = async (taskId) => {
        const maxAttempts = 60;
        let attempts = 0;

        while (attempts < maxAttempts) {
            try {
                const response = await fetch(`http://127.0.0.1:5000/api/music/task/status?taskId=${taskId}`);
                if (!response.ok) throw new Error('작업 상태 확인 실패');

                const statusData = await response.json();
                console.log('작업 상태:', statusData);
                
                if (statusData.status === 'succeeded') {
                    const musicData = {
                        id: statusData.result?.id || `score_${Date.now()}`,
                        title: statusData.result?.title || `악보 기반 생성 음악`,
                        audioUrl: statusData.audioUrl || statusData.result?.audioUrl,
                        genres: statusData.result?.genres || ['Classical'],
                        moods: statusData.result?.moods || [],
                        duration: statusData.result?.duration || 180,
                        createdAt: statusData.result?.createdAt || new Date().toISOString(),
                        type: 'score-generated',
                        originalFile: fileName,
                        targetGenre: 'Classical',
                        format: format
                    };

                    console.log('생성된 musicData:', musicData);

                    if (actions.setResult) actions.setResult({ convertedMusic: musicData });
                    localStorage.setItem('scoreGeneratedMusic', JSON.stringify(musicData));

                    return true;
                } else if (statusData.status === 'failed') {
                    throw new Error(statusData.error || '음악 생성 실패');
                } else if (statusData.status === 'running' || statusData.status === 'queued') {
                    console.log(`작업 진행중... (${attempts + 1}/${maxAttempts})`);
                    await new Promise(resolve => setTimeout(resolve, 5000));
                    attempts++;
                } else {
                    throw new Error(`알 수 없는 작업 상태: ${statusData.status}`);
                }
            } catch (error) {
                console.error('작업 상태 확인 중 오류:', error);
                throw error;
            }
        }
        throw new Error('작업 시간 초과 (30분)');
    };

    const handleSubmit = async () => {
    if (!pdfFile) {
        alert("악보 PDF 파일을 업로드해주세요.");
        return;
    }

    setIsLoading(true);
    const formData = new FormData();
    formData.append('score', pdfFile);
    formData.append('format', format); // 선택된 변환 형식 전송

    try {
        console.log('=== 악보 처리 시작 ===');
        const response = await fetch('http://127.0.0.1:5000/api/process-score', {
            method: 'POST',
            body: formData,
        });

        if (!response.ok) {
            const errorData = await response.json();
            throw new Error(errorData.message || '음악 생성에 실패했습니다.');
        }

        const data = await response.json();
        console.log('서버 응답:', data);

        const taskId = data.taskId;
        if (!taskId) throw new Error('작업 ID를 받을 수 없습니다.');

        await pollTaskStatus(taskId);

        // ✅ navigate를 먼저 실행 (setIsLoading보다 우선)
        navigate('/result');

    } catch (error) {
        console.error("Error generating music from score:", error);
        alert(`음악 생성 중 오류가 발생했습니다: ${error.message}`);
    } finally {
        // ✅ navigate 후 1초 뒤 상태 해제 (안정성 확보)
        setTimeout(() => setIsLoading(false), 1000);
    }
};


    return (
        <Box
            sx={{
                width: '100%',
                minHeight: '100vh',
                bgcolor: '#000',
                display: 'flex',
                justifyContent: 'center',
                alignItems: 'flex-start',
                pt: 8,
                pb: 4,
            }}
        >
            <Box
                sx={{
                    width: { xs: '90%', sm: '600px' },
                    bgcolor: '#1A1A1A',
                    borderRadius: 3,
                    p: { xs: 3, sm: 4 },
                    textAlign: 'center',
                    boxShadow: '0 0 20px rgba(80, 227, 194, 0.2)',
                    color: '#FFF'
                }}
            >
                <Typography variant="h4" gutterBottom>
                    악보 연주하기
                </Typography>
                <Typography variant="body1" sx={{ mb: 4, color: '#CCC' }}>
                    PDF 악보 파일을 업로드하면 AI가 분석하여 음악을 연주해줍니다.
                </Typography>

                {/* 파일 업로드 영역 */}
                <Box
                    sx={{
                        border: '2px dashed #555',
                        borderRadius: '10px',
                        p: 4,
                        mb: 3,
                        cursor: 'pointer',
                        bgcolor: '#0a0a0a',
                        '&:hover': {
                            borderColor: '#50E3C2',
                            bgcolor: '#111'
                        }
                    }}
                    onClick={() => document.getElementById('pdf-upload').click()}
                >
                    <UploadFileIcon sx={{ fontSize: 60, color: '#777' }} />
                    <Typography sx={{ color: '#CCC', mt: 1 }}>
                        {fileName || '클릭하여 PDF 파일을 선택하세요'}
                    </Typography>
                    <input
                        type="file"
                        id="pdf-upload"
                        hidden
                        accept="application/pdf"
                        onChange={handleFileChange}
                    />
                </Box>

                {/* 변환 형식 선택 */}
                <FormControl
                    fullWidth
                    sx={{ mb: 3, bgcolor: '#0a0a0a', borderRadius: 1 }}
                >
                    <InputLabel sx={{ color: '#CCC' }}>변환 형식</InputLabel>
                    <Select
                        value={format}
                        onChange={handleFormatChange}
                        sx={{
                            color: '#FFF',
                            borderColor: '#555',
                            '.MuiOutlinedInput-notchedOutline': { borderColor: '#555' },
                            '&:hover .MuiOutlinedInput-notchedOutline': { borderColor: '#50E3C2' },
                            '& .MuiSvgIcon-root': { color: '#50E3C2' },
                        }}
                    >
                        <MenuItem value="midi">MIDI로 변환</MenuItem>
                        <MenuItem value="wav">WAV로 변환</MenuItem>
                       
                    </Select>
                </FormControl>

                {/* 변환 버튼 */}
                <Button
                    variant="contained"
                    color="primary"
                    size="large"
                    onClick={handleSubmit}
                    disabled={isLoading || !pdfFile}
                    sx={{
                        minWidth: '200px',
                        minHeight: '50px',
                        bgcolor: '#50E3C2',
                        color: '#000',
                        fontWeight: 600,
                        '&:hover': { bgcolor: '#40D9B8' },
                        '&:disabled': { bgcolor: '#333', color: '#666' }
                    }}
                >
                    {isLoading ? (
                        <Box sx={{ display: 'flex', alignItems: 'center', gap: 2 }}>
                            <CircularProgress size={24} color="inherit" />
                            <span>처리 중...</span>
                        </Box>
                    ) : (
                        '변환하기'
                    )}
                </Button>

                {/* 로딩 상태 표시 */}
                {isLoading && (
                    <Box sx={{ mt: 3 }}>
                        <Typography variant="body2" sx={{ color: '#AAA', mb: 1 }}>
                            악보를 분석하고 {format.toUpperCase()} 형식으로 변환 중입니다...
                        </Typography>
                        <Typography variant="caption" sx={{ color: '#666' }}>
                            최대 10분이 소요될 수 있습니다.
                        </Typography>
                    </Box>
                )}
            </Box>
        </Box>
    );
};

export default ScoreToMusic;
</file>

<file path="src/polyfills.js">
// src/polyfills.js
import { Buffer } from 'buffer';
if (!window.Buffer) window.Buffer = Buffer;
if (!window.global) window.global = window;
</file>

<file path="src/reportWebVitals.js">
const reportWebVitals = onPerfEntry => {
  if (onPerfEntry && onPerfEntry instanceof Function) {
    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {
      getCLS(onPerfEntry);
      getFID(onPerfEntry);
      getFCP(onPerfEntry);
      getLCP(onPerfEntry);
      getTTFB(onPerfEntry);
    });
  }
};

export default reportWebVitals;
</file>

<file path="src/services/libraryApi.js">
import {
  collection,
  doc,
  onSnapshot,
  orderBy,
  query,
  where,
  limit,
} from 'firebase/firestore';

import { db } from '../lib/firebase';

const COLLECTION_TRACKS = 'tracks';
const COLLECTION_BEATS = 'beats';

function normalizeDoc(snapshot, type) {
  if (!snapshot.exists()) return null;
  const data = snapshot.data();
  return {
    id: snapshot.id,
    type,
    ...data,
  };
}

export function subscribeToUserLibrary(userId, { onUpdate, onError } = {}) {
  if (!userId) return () => {};

  const tracksQuery = query(
    collection(db, COLLECTION_TRACKS),
    where('ownerId', '==', userId),
    orderBy('createdAt', 'desc'),
    limit(200)
  );

  const beatsQuery = query(
    collection(db, COLLECTION_BEATS),
    where('ownerId', '==', userId),
    orderBy('createdAt', 'desc'),
    limit(200)
  );

  let currentTracks = [];
  let currentBeats = [];

  const emit = () => {
    const combined = [...currentTracks, ...currentBeats].sort((a, b) => {
      const aDate = a.createdAt?.toMillis ? a.createdAt.toMillis() : new Date(a.createdAt || 0).getTime();
      const bDate = b.createdAt?.toMillis ? b.createdAt.toMillis() : new Date(b.createdAt || 0).getTime();
      return bDate - aDate;
    });
    onUpdate?.(combined);
  };

  const unsubTracks = onSnapshot(
    tracksQuery,
    (snap) => {
      currentTracks = snap.docs
        .map((docSnap) => normalizeDoc(docSnap, 'track'))
        .filter(Boolean);
      emit();
    },
    (error) => {
      console.warn('[libraryApi] tracks subscription error', error);
      onError?.(error);
    }
  );

  const unsubBeats = onSnapshot(
    beatsQuery,
    (snap) => {
      currentBeats = snap.docs
        .map((docSnap) => normalizeDoc(docSnap, 'beat'))
        .filter(Boolean);
      emit();
    },
    (error) => {
      console.warn('[libraryApi] beats subscription error', error);
      onError?.(error);
    }
  );

  return () => {
    unsubTracks?.();
    unsubBeats?.();
  };
}

export function getTrackDocRef(trackId) {
  return doc(db, COLLECTION_TRACKS, trackId);
}

export function getBeatDocRef(beatId) {
  return doc(db, COLLECTION_BEATS, beatId);
}

export default {
  subscribeToUserLibrary,
  getTrackDocRef,
  getBeatDocRef,
};
</file>

<file path="src/services/libraryWriter.js">
import {
  addDoc,
  collection,
  serverTimestamp,
  updateDoc,
} from 'firebase/firestore';
import {
  ref as storageRef,
  uploadBytes,
  getDownloadURL,
} from 'firebase/storage';

import { db, storage } from '../lib/firebase';

async function uploadAudioBlob({ ownerId, docId, blob, folder }) {
  if (!blob) return null;
  const ref = storageRef(storage, `audio/${folder}/${ownerId}/${docId}.wav`);
  await uploadBytes(ref, blob, { contentType: 'audio/wav' });
  return getDownloadURL(ref);
}

async function loadBlobFromUrl(url) {
  if (!url) return null;
  const response = await fetch(url);
  if (!response.ok) throw new Error('오디오 파일을 불러오지 못했습니다.');
  return response.blob();
}

export async function saveGeneratedTrack({
  ownerId,
  title,
  genres,
  moods,
  description,
  durationSec,
  prompt,
  sourceUrl,
}) {
  const payload = {
    ownerId,
    title,
    genres,
    moods,
    description,
    duration: durationSec,
    prompt,
    source: 'musicgen',
    createdAt: serverTimestamp(),
  };

  const tracksCol = collection(db, 'tracks');
  const docRef = await addDoc(tracksCol, payload);

  try {
    const blob = await loadBlobFromUrl(sourceUrl);
    const url = await uploadAudioBlob({ ownerId, docId: docRef.id, blob, folder: 'tracks' });
    await updateDoc(docRef, { audioUrl: url, sourceUrl });
  } catch (error) {
    // 업로드 실패 시에도 문서 기본 정보는 유지되도록 로그만 남김
    console.warn('[libraryWriter] track audio upload failed', error);
  }

  return docRef.id;
}

export async function saveBeatItem({
  ownerId,
  title,
  bpm,
  bars,
  pattern,
  audioBlob,
  presetMeta,
}) {
  const payload = {
    ownerId,
    title,
    bpm,
    bars,
    pattern,
    presetMeta,
    source: 'beatmaker',
    createdAt: serverTimestamp(),
  };

  const beatsCol = collection(db, 'beats');
  const docRef = await addDoc(beatsCol, payload);

  try {
    const url = await uploadAudioBlob({ ownerId, docId: docRef.id, blob: audioBlob, folder: 'beats' });
    await updateDoc(docRef, { audioUrl: url });
  } catch (error) {
    console.warn('[libraryWriter] beat audio upload failed', error);
  }

  return docRef.id;
}

export default {
  saveGeneratedTrack,
  saveBeatItem,
};
</file>

<file path="src/services/musicApi.js">
// src/services/musicApi.js

const IN_PROGRESS = new Set(['queued', 'running', 'processing', 'starting', 'pending']);
const sleep = (ms) => new Promise((r) => setTimeout(r, ms));

// 기본값은 5000포트. .env에 REACT_APP_API_BASE_URL 있으면 그걸 사용합니다. :contentReference[oaicite:5]{index=5}
const API_BASE = (process.env.REACT_APP_API_BASE_URL || 'http://127.0.0.1:5000/api').replace(/\/$/, '');

function pickStatus(j) {
  const candidates = [ j?.status, j?.state, j?.task_status, j?.taskStatus, j?.prediction?.status, j?.data?.status ];
  const raw = candidates.find((v) => v != null) ?? '';
  return String(raw).toLowerCase();
}

function pickAudioUrl(j) {
  const candidates = [
    j?.audioUrl, j?.audio_url, j?.url,
    j?.result?.audioUrl, j?.result?.audio_url, j?.result?.url, j?.result?.audio,
    j?.data?.audioUrl, j?.data?.audio_url, j?.data?.url, j?.data?.audio,
    j?.prediction?.output,
    j?.output,
    j?.files
  ];
  let out = candidates.find((v) => v != null);
  if (Array.isArray(out)) out = out[0];
  if (out && typeof out === 'object') {
    if (typeof out.url === 'string') out = out.url;
    else if (typeof out.audio === 'string') out = out.audio;
    else if (Array.isArray(out.output)) out = out.output[0];
  }
  if (typeof out === 'string') return out;
  return undefined;
}

/**
 * 파일이 있으면 multipart/form-data, 없으면 JSON으로 호출
 * payload: { description, genres, moods, duration }
 * file: File | null
 */
export async function generateAndWait(payload, onStatus, file = null) {
  let genRes;
  if (file) {
    const fd = new FormData();
    fd.append('description', payload.description || '');
    fd.append('genres', JSON.stringify(payload.genres || []));
    fd.append('moods', JSON.stringify(payload.moods || []));
    fd.append('duration', String(payload.duration || 10));
    fd.append('file', file);
    genRes = await fetch(`${API_BASE}/music/generate`, { method: 'POST', body: fd });
  } else {
    genRes = await fetch(`${API_BASE}/music/generate`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(payload),
    });
  }
  if (!genRes.ok) throw new Error(`Generate failed: ${genRes.status} ${await genRes.text()}`);
  const genJson = await genRes.json();

  const taskId = genJson.task_id || genJson.taskId || genJson.id;
  if (!taskId) throw new Error('No task id from server');

  // 상태 폴링 (기존 구현과 동일 — /api/music/task/status?task_id=...) :contentReference[oaicite:6]{index=6}
  while (true) {
    await sleep(1500);
    const stRes = await fetch(`${API_BASE}/music/task/status?task_id=${encodeURIComponent(taskId)}`);
    const stJson = await stRes.json();
    onStatus?.(stJson);

    const st = pickStatus(stJson);
    if (!st || IN_PROGRESS.has(st)) continue;

    if (!['succeeded', 'completed', 'success'].includes(st)) {
      const errMsg = stJson?.error || stJson?.message || stJson?.result?.error || stJson?.prediction?.error || `Generation failed (${st || 'unknown'})`;
      throw new Error(errMsg);
    }

    const audioUrl = pickAudioUrl(stJson);
    if (!audioUrl) throw new Error('Replicate returned no audio URL.');
    return { status: 'succeeded', result: { audioUrl } };
  }
}
</file>

<file path="src/setupTests.js">
// jest-dom adds custom jest matchers for asserting on DOM nodes.
// allows you to do things like:
// expect(element).toHaveTextContent(/react/i)
// learn more: https://github.com/testing-library/jest-dom
import '@testing-library/jest-dom';
</file>

<file path="src/state/beatPadStore.js">
import React, { createContext, useContext, useReducer, useMemo } from "react";
import { clonePattern, PRESETS } from "../components/beat/presets";

const BeatPadContext = createContext(null);

const initialState = {
  // --- 재생 및 시퀀서 관련 ---
  isPlaying: false,
  bpm: 60,
  currentStep: 0,
  pattern: clonePattern(PRESETS["Rock 1"]),

  // --- 블렌딩 패드(그리드) 관련 ---
  grid: { cols: 11, rows: 11 },
  puckPosition: { x: 0.5, y: 0.5 },
  selectedCellIndex: 60,

  // --- AI 모델 및 데이터 관련 ---
  cornerPresets: {
    A: "Rock 1",
    B: "Pop Punk",
    C: "Reggaeton",
    D: "Samba Full Time",
  },
  cornerPatterns: {
    A: PRESETS["Rock 1"],
    B: PRESETS["Pop Punk"],
    C: PRESETS["Reggaeton"],
    D: PRESETS["Samba Full Time"],
  },
  cornerEncodings: null,
  gridCellPatterns: [],
  isInterpolating: false,

  // --- UI 모드 관련 ---
  mode: "INTERPOLATE", // 'INTERPOLATE' | 'EDIT'
  selectedCorner: null, // 'A' | 'B' | 'C' | 'D' | null
  drawMode: "DRAG", // 'DRAG' | 'PATH'
  path: [],

  // --- 캐시 관리 ---
  cellCacheVersion: 0,
};

function reducer(state, action) {
  switch (action.type) {
    case "SET_IS_PLAYING":
      return { ...state, isPlaying: action.payload };

    case "SET_BPM":
      return { ...state, bpm: action.payload };

    case "SET_CURRENT_STEP":
      return { ...state, currentStep: action.payload };

    case "SET_PATTERN":
      return { ...state, pattern: action.payload };

    case "SET_PUCK_POSITION":
      return {
        ...state,
        puckPosition: action.payload.position,
        selectedCellIndex: action.payload.index,
      };

    case "SET_DRAW_MODE":
      return {
        ...state,
        drawMode: action.payload,
        path: action.payload === "PATH" ? [] : state.path,
      };

    case "RESET_PATH":
      return { ...state, path: [] };

    case "APPEND_PATH_POINT":
      return { ...state, path: [...state.path, action.payload] };

    case "SET_PATH":
      return { ...state, path: action.payload };

    case "SET_CORNER_PRESET": {
      const { corner, presetName } = action.payload;
      const presetPattern = PRESETS[presetName] || PRESETS["Rock 1"];
      return {
        ...state,
        cornerPresets: { ...state.cornerPresets, [corner]: presetName },
        cornerPatterns: {
          ...state.cornerPatterns,
          [corner]: clonePattern(presetPattern),
        },
        cornerEncodings: null,
        cellCacheVersion: state.cellCacheVersion + 1,
      };
    }

    case "SET_CORNER_ENCODINGS":
      return { ...state, cornerEncodings: action.payload };

    case "SET_MODE":
      return { ...state, mode: action.payload };

    case "SELECT_CORNER":
      return { ...state, selectedCorner: action.payload };

    case "UPDATE_EDITING_PATTERN": {
      if (!state.selectedCorner) return state;
      const { track, step } = action.payload;
      const newCornerPatterns = { ...state.cornerPatterns };
      const newPattern = clonePattern(newCornerPatterns[state.selectedCorner]);
      newPattern[track][step] = !newPattern[track][step];
      newCornerPatterns[state.selectedCorner] = newPattern;
      return { ...state, cornerPatterns: newCornerPatterns };
    }

    case "START_INTERPOLATION":
      return { ...state, isInterpolating: true };

    case "FINISH_INTERPOLATION":
      return {
        ...state,
        isInterpolating: false,
        cornerEncodings: action.payload.encodings,
        gridCellPatterns: action.payload.patterns,
        mode: "INTERPOLATE",
        selectedCorner: null,
      };

    // (이후 단계에서 더 많은 액션을 추가할 예정입니다)

    default:
      return state;
  }
}

export function BeatPadProvider({ children }) {
  const [state, dispatch] = useReducer(reducer, initialState);
  const value = useMemo(() => ({ state, dispatch }), [state]);
  return <BeatPadContext.Provider value={value}>{children}</BeatPadContext.Provider>;
}

export const useBeatPad = () => useContext(BeatPadContext);
</file>

<file path="src/styles/beatpad.css">
/* 패드 컨테이너(크기/둥근모서리/배경) */
.pad-stack {
  position: relative;
  width: 100%;
  height: 320px;          /* 필요하면 360px 등으로 바꿔도 됨 */
  border-radius: 12px;
  overflow: hidden;
  background: #1b1b1b;
  /* 기본 그리드 느낌의 배경(셀 수와 정확히 일치하진 않지만 빈 화면 방지용) */
  background-image:
    repeating-linear-gradient(0deg, rgba(255,255,255,0.05) 0 1px, transparent 1px 24px),
    repeating-linear-gradient(90deg, rgba(255,255,255,0.05) 0 1px, transparent 1px 24px);
  background-size: 100% 100%;
}

/* 두 캔버스는 래퍼를 꽉 채움 */
.blendpad-canvas,
.blendpad-ghost {
  position: absolute;
  inset: 0;
  width: 100%;
  height: 100%;
  display: block;
}

/* 클릭/드래그용 캔버스 */
.blendpad-canvas {
  cursor: crosshair;         /* 셀 모드일 때 */
}

/* 고스트 미리보기는 포인터를 막아야 클릭이 아래로 전달됨 */
.blendpad-ghost {
  pointer-events: none;
}

/* (선택) 다크 테마 경계 강조 */
.pad-stack::after {
  content: '';
  position: absolute;
  inset: 0;
  border: 1px solid rgba(255,255,255,0.07);
  border-radius: 12px;
  pointer-events: none;
}

.path-overlay{
  position:absolute;
  inset:0;
  width:100%;
  height:100%;
  pointer-events:none;          /* 경로 캔버스는 클릭 막지 않도록 */
  z-index:3;
}
</file>

<file path="src/utils/audioExport.js">
// src/utils/audioExport.js

export function audioBufferToWav(buffer) {
  const numChannels = buffer.numberOfChannels;
  const sampleRate = buffer.sampleRate;
  const format = 1; // PCM
  const bitDepth = 16;
  const bytesPerSample = bitDepth / 8;
  const blockAlign = numChannels * bytesPerSample;

  const dataLength = buffer.length * blockAlign;
  const bufferLength = 44 + dataLength;

  const arrayBuffer = new ArrayBuffer(bufferLength);
  const view = new DataView(arrayBuffer);

  writeString(view, 0, "RIFF");
  view.setUint32(4, 36 + dataLength, true);
  writeString(view, 8, "WAVE");

  writeString(view, 12, "fmt ");
  view.setUint32(16, 16, true);
  view.setUint16(20, format, true);
  view.setUint16(22, numChannels, true);
  view.setUint32(24, sampleRate, true);
  view.setUint32(28, sampleRate * blockAlign, true);
  view.setUint16(32, blockAlign, true);
  view.setUint16(34, bitDepth, true);

  writeString(view, 36, "data");
  view.setUint32(40, dataLength, true);

  let offset = 44;
  for (let i = 0; i < buffer.length; i++) {
    for (let channel = 0; channel < numChannels; channel++) {
      const sample = buffer.getChannelData(channel)[i];
      const s = Math.max(-1, Math.min(1, sample));
      view.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7fff, true);
      offset += 2;
    }
  }

  return new Blob([view], { type: "audio/wav" });
}

function writeString(view, offset, string) {
  for (let i = 0; i < string.length; i++) {
    view.setUint8(offset + i, string.charCodeAt(i));
  }
}
</file>

<file path="UI_UX_DESIGN.md">
# AI 기반 배경음악 생성 및 변환 시스템 - UI/UX 설계 문서

## 1. 프로젝트 개요
AI를 활용하여 사용자가 원하는 분위기와 장르의 배경음악을 생성하고, 기존 음악을 새로운 스타일로 변환하는 웹 애플리케이션

## 2. 사용자 페르소나
- **주요 사용자**: 콘텐츠 크리에이터, 영상 편집자, 게임 개발자, 일반 음악 애호가
- **니즈**: 저작권 걱정 없는 배경음악, 빠른 음악 생성, 다양한 스타일 변환

## 3. 페이지 구성 및 와이어프레임

### 3.1 메인 네비게이션
```
[로고] AI Music Studio    [음악 생성] [음악 변환] [라이브러리] [설정]
```

### 3.2 음악 생성 페이지 (메인 페이지)
```
┌─────────────────────────────────────────────────────────────┐
│                    🎵 AI Music Studio                       │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  🎹 새로운 음악 생성                                          │
│                                                             │
│  ┌─ 장르 선택 ─────────────────────────────────────────────┐ │
│  │ [EDM] [Lo-Fi] [City Pop] [어쿠스틱] [클래식] [재즈]      │ │
│  │ [힙합] [록] [팝] [앰비언트] [기타...]                    │ │
│  └───────────────────────────────────────────────────────────┘ │
│                                                             │
│  ┌─ 분위기 키워드 ─────────────────────────────────────────┐ │
│  │ #신나는 #차분한 #몽환적인 #에너지틱 #로맨틱 #집중       │ │
│  │ #슬픈 #희망적인 #긴장감 #편안한                         │ │
│  └───────────────────────────────────────────────────────────┘ │
│                                                             │
│  ┌─ 상세 설명 (선택사항) ──────────────────────────────────┐ │
│  │ ┌─────────────────────────────────────────────────────┐ │ │
│  │ │ 예: "카페에서 공부할 때 듣기 좋은 차분한 피아노 음악" │ │ │
│  │ │                                                     │ │ │
│  │ │                                                     │ │ │
│  │ └─────────────────────────────────────────────────────┘ │ │
│  └───────────────────────────────────────────────────────────┘ │
│                                                             │
│  ┌─ 음악 길이 ─────────────────────────────────────────────┐ │
│  │ ○ 30초  ○ 1분  ● 2분  ○ 5분  ○ 사용자 정의 [___]분   │ │
│  └───────────────────────────────────────────────────────────┘ │
│                                                             │
│         [🎵 음악 생성하기] [⚙️ 고급 설정]                    │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### 3.3 음악 변환 페이지
```
┌─────────────────────────────────────────────────────────────┐
│                 🔄 음악 스타일 변환                          │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  ┌─ 원본 음악 업로드 ──────────────────────────────────────┐ │
│  │     📁 파일 선택 또는 드래그 앤 드롭                     │ │
│  │     지원 형식: MP3, WAV, M4A (최대 10MB)                 │ │
│  │                                                         │ │
│  │  [선택된 파일: song.mp3] [🗑️ 제거]                      │ │
│  └───────────────────────────────────────────────────────────┘ │
│                                                             │
│  ┌─ 원본 미리듣기 ─────────────────────────────────────────┐ │
│  │  ▶️ [■■■■■■■■■□] 2:30 / 3:45                          │ │
│  └───────────────────────────────────────────────────────────┘ │
│                                                             │
│  ┌─ 변환할 스타일 선택 ────────────────────────────────────┐ │
│  │ [EDM] [Lo-Fi] [City Pop] [어쿠스틱] [클래식] [재즈]      │ │
│  │ [힙합] [록] [팝] [앰비언트]                              │ │
│  └───────────────────────────────────────────────────────────┘ │
│                                                             │
│  ┌─ 변환 강도 ─────────────────────────────────────────────┐ │
│  │ 약간 [●●●○○] 강하게                                     │ │
│  │ (원곡의 특성을 얼마나 유지할지 조정)                     │ │
│  └───────────────────────────────────────────────────────────┘ │
│                                                             │
│              [🔄 변환 시작하기]                              │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### 3.4 결과 페이지 (생성/변환 완료)
```
┌─────────────────────────────────────────────────────────────┐
│                    ✅ 생성 완료!                             │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  ┌─ 생성된 음악 ──────────────────────────────────────────┐ │
│  │  🎵 AI_Generated_Music_001.mp3                          │ │
│  │  장르: Lo-Fi | 분위기: 차분한, 집중                      │ │
│  │  길이: 2:00                                             │ │
│  │                                                         │ │
│  │  ▶️ [■■■■■■■■■□] 1:30 / 2:00                          │ │
│  │  🔊 [────●────] 볼륨                                    │ │
│  └───────────────────────────────────────────────────────────┘ │
│                                                             │
│  ┌─ 액션 버튼 ─────────────────────────────────────────────┐ │
│  │  [💾 다운로드] [💖 즐겨찾기] [🔄 다시 생성] [📤 공유]    │ │
│  └───────────────────────────────────────────────────────────┘ │
│                                                             │
│  ┌─ 생성 정보 ─────────────────────────────────────────────┐ │
│  │  • 생성 시간: 2024-01-15 14:30                          │ │
│  │  • 사용된 프롬프트: "카페에서 공부할 때..."             │ │
│  │  • AI 모델: MusicGen v2.1                               │ │
│  └───────────────────────────────────────────────────────────┘ │
│                                                             │
│            [🏠 홈으로] [📚 라이브러리에서 보기]               │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### 3.5 라이브러리 페이지 (선택사항)
```
┌─────────────────────────────────────────────────────────────┐
│                   📚 내 음악 라이브러리                       │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  [🔍 검색] [📅 날짜순] [⭐ 즐겨찾기] [🎵 장르별]              │
│                                                             │
│  ┌────────┬────────┬────────┬────────┬────────┬────────┐     │
│  │🎵 001  │🎵 002  │🎵 003  │🎵 004  │🎵 005  │🎵 006  │     │
│  │Lo-Fi   │EDM     │Acoustic│City Pop│Jazz    │Rock    │     │
│  │2:00    │3:15    │4:30    │2:45    │5:20    │3:00    │     │
│  │▶️ 💾 🗑️│▶️ 💾 🗑️│▶️ 💾 🗑️│▶️ 💾 🗑️│▶️ 💾 🗑️│▶️ 💾 🗑️│     │
│  └────────┴────────┴────────┴────────┴────────┴────────┘     │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

## 4. 사용자 흐름 (User Flow)

### 4.1 음악 생성 플로우
```
시작 → 메인 페이지 → 장르 선택 → 분위기 키워드 선택 → (선택)상세 설명 입력 
→ 음악 길이 설정 → 생성 버튼 클릭 → 로딩 화면 → 결과 페이지 → 미리듣기 
→ 다운로드/저장 → (선택)라이브러리 이동 또는 새 생성
```

### 4.2 음악 변환 플로우
```
시작 → 음악 변환 페이지 → 파일 업로드 → 원본 미리듣기 → 변환 스타일 선택 
→ 변환 강도 조정 → 변환 버튼 클릭 → 로딩 화면 → 결과 페이지 → 비교 듣기 
→ 다운로드/저장 → (선택)라이브러리 이동 또는 새 변환
```

## 5. 디자인 시스템

### 5.1 컬러 팔레트
- **Primary**: #6366F1 (인디고) - 메인 액션 버튼, 링크
- **Secondary**: #8B5CF6 (보라) - 보조 액션, 강조
- **Accent**: #06B6D4 (청록) - 성공, 완료 상태
- **Background**: #F8FAFC (연한 회색) - 페이지 배경
- **Surface**: #FFFFFF (흰색) - 카드, 패널 배경
- **Text Primary**: #1E293B (진한 회색) - 주요 텍스트
- **Text Secondary**: #64748B (중간 회색) - 보조 텍스트
- **Success**: #10B981 (초록) - 성공 메시지
- **Warning**: #F59E0B (주황) - 경고 메시지
- **Error**: #EF4444 (빨강) - 오류 메시지

### 5.2 타이포그래피
- **Heading 1**: 2.5rem, Bold - 페이지 제목
- **Heading 2**: 2rem, Semi-bold - 섹션 제목
- **Heading 3**: 1.5rem, Medium - 카드 제목
- **Body**: 1rem, Regular - 본문 텍스트
- **Caption**: 0.875rem, Regular - 설명 텍스트
- **Button**: 1rem, Medium - 버튼 텍스트

### 5.3 간격 체계
- **XS**: 4px
- **SM**: 8px
- **MD**: 16px
- **LG**: 24px
- **XL**: 32px
- **2XL**: 48px

### 5.4 컴포넌트 가이드라인

#### 버튼
- **Primary Button**: 둥근 모서리 (8px), 그림자 효과, hover 시 색상 변경
- **Secondary Button**: 테두리만 있는 스타일, Primary 컬러 테두리
- **Icon Button**: 아이콘만 있는 원형 또는 사각형 버튼

#### 입력 필드
- **Text Input**: 둥근 모서리 (6px), 연한 테두리, focus 시 Primary 컬러 테두리
- **File Upload**: 점선 테두리, 드래그 앤 드롭 영역 표시

#### 카드
- **기본 카드**: 흰색 배경, 연한 그림자, 둥근 모서리 (12px)
- **음악 카드**: 썸네일, 제목, 정보, 액션 버튼 포함

#### 태그/키워드
- **장르 태그**: 둥근 모서리, 클릭 가능, 선택 시 색상 변경
- **분위기 키워드**: # 접두사, 작은 크기, 여러 개 선택 가능

## 6. 반응형 디자인 고려사항

### 6.1 브레이크포인트
- **Mobile**: < 768px
- **Tablet**: 768px - 1024px  
- **Desktop**: > 1024px

### 6.2 모바일 최적화
- 터치 친화적인 버튼 크기 (최소 44px)
- 세로 스크롤 중심 레이아웃
- 간소화된 네비게이션 (햄버거 메뉴)
- 한 화면에 하나의 주요 액션에 집중

## 7. 접근성 고려사항
- 키보드 네비게이션 지원
- 충분한 색상 대비 (WCAG 2.1 AA 기준)
- 스크린 리더 지원을 위한 적절한 ARIA 레이블
- 포커스 인디케이터 제공

## 8. 로딩 및 피드백
- 음악 생성 중: 진행률 표시, 예상 소요 시간 안내
- 파일 업로드: 진행률 바, 업로드 상태 표시
- 에러 처리: 명확한 에러 메시지, 해결 방법 제시
- 성공 피드백: 토스트 메시지, 시각적 확인
</file>

</files>
